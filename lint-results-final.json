[{"filePath":"C:\\Users\\LGSM228\\CivStrategy\\App.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\LGSM228\\CivStrategy\\components\\GameUI.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\LGSM228\\CivStrategy\\components\\LoadingScreen.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\LGSM228\\CivStrategy\\components\\MainMenu.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\LGSM228\\CivStrategy\\components\\PhaserGame.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\LGSM228\\CivStrategy\\constants.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\LGSM228\\CivStrategy\\eslint.config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\LGSM228\\CivStrategy\\game\\MainScene.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":265,"column":57,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":265,"endColumn":60,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11045,11048],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11045,11048],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":369,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":369,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15156,15159],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15156,15159],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":377,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":377,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15526,15529],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15526,15529],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\LGSM228\\CivStrategy\\game\\systems\\BuildingManager.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":274,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":274,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11728,11731],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11728,11731],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'buildingWidth' is defined but never used. Allowed unused args must match /^_/u.","line":286,"column":63,"nodeType":null,"messageId":"unusedVar","endLine":286,"endColumn":76},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":355,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":355,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14419,14422],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14419,14422],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":71,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":71,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2923,2926],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2923,2926],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":205,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":205,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8639,8642],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8639,8642],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":217,"column":51,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":217,"endColumn":54,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9251,9254],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9251,9254],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":238,"column":51,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":238,"endColumn":54,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10284,10287],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10284,10287],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\r\nimport Phaser from 'phaser';\r\nimport { MainScene } from '../MainScene';\r\nimport { BuildingType, BuildingDef, UnitState, UnitType } from '../../types';\r\nimport { BUILDINGS, EVENTS, TILE_SIZE } from '../../constants';\r\nimport { toIso, toCartesian } from '../utils/iso';\r\n\r\nexport class BuildingManager {\r\n    private scene: MainScene;\r\n    public previewBuilding: Phaser.GameObjects.Container | null = null;\r\n    public previewBuildingType: BuildingType | null = null;\r\n    public isDemolishMode: boolean = false;\r\n    private treeHighlightGraphics: Phaser.GameObjects.Graphics;\r\n    private territoryGraphics: Phaser.GameObjects.Graphics;\r\n    private isTerritoryDirty: boolean = true;\r\n\r\n    constructor(scene: MainScene) {\r\n        this.scene = scene;\r\n        this.treeHighlightGraphics = this.scene.add.graphics().setDepth(Number.MAX_VALUE - 500);\r\n        this.territoryGraphics = this.scene.add.graphics().setDepth(-5000);\r\n\r\n        this.scene.game.events.on('request-build', this.enterBuildMode, this);\r\n        this.scene.game.events.on(EVENTS.TOGGLE_DEMOLISH, this.toggleDemolishMode, this);\r\n        this.scene.game.events.on(EVENTS.REGROW_FOREST, this.handleRegrowForest, this);\r\n        this.scene.game.events.on(EVENTS.DEMOLISH_SELECTED, this.handleDemolishSelected, this);\r\n    }\r\n\r\n    public update() {\r\n        if (this.isTerritoryDirty) {\r\n            this.drawTerritory();\r\n            this.isTerritoryDirty = false;\r\n        }\r\n    }\r\n\r\n    public markTerritoryDirty() {\r\n        this.isTerritoryDirty = true;\r\n    }\r\n\r\n    public enterBuildMode(buildingType: BuildingType) {\r\n        const def = BUILDINGS[buildingType];\r\n        if (!def) return;\r\n\r\n        if (this.isDemolishMode) {\r\n            this.toggleDemolishMode(false);\r\n            this.scene.game.events.emit(EVENTS.TOGGLE_DEMOLISH, false);\r\n        }\r\n\r\n        if (this.previewBuilding) this.previewBuilding.destroy();\r\n        this.previewBuildingType = buildingType;\r\n        this.previewBuilding = this.scene.add.container(0, 0);\r\n        const gfx = this.scene.add.graphics();\r\n        this.scene.entityFactory.drawIsoBuilding(gfx, def, 0xffffff, 0.5);\r\n        this.previewBuilding.add(gfx);\r\n        this.previewBuilding.setDepth(Number.MAX_VALUE);\r\n        this.previewBuilding.setVisible(false);\r\n    }\r\n\r\n    public toggleDemolishMode(isActive: boolean) {\r\n        this.isDemolishMode = isActive;\r\n        if (this.isDemolishMode) {\r\n            this.scene.inputManager.clearSelection();\r\n            this.previewBuildingType = null;\r\n            if (this.previewBuilding) {\r\n                this.previewBuilding.destroy();\r\n                this.previewBuilding = null;\r\n            }\r\n            this.scene.input.setDefaultCursor('crosshair');\r\n        } else {\r\n            this.scene.input.setDefaultCursor('default');\r\n            this.scene.buildings.getChildren().forEach((b) => {\r\n                const visual = (b as any).visual as Phaser.GameObjects.Container; // eslint-disable-line @typescript-eslint/no-explicit-any\r\n                if (visual) {\r\n                    const highlight = visual.getData('demolishHighlight') as Phaser.GameObjects.Graphics;\r\n                    if (highlight) {\r\n                        highlight.destroy();\r\n                        visual.setData('demolishHighlight', null);\r\n                    }\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    public updatePreview(worldX: number, worldY: number) {\r\n        if (!this.previewBuildingType || !this.previewBuilding) return;\r\n\r\n        this.previewBuilding.setVisible(true);\r\n\r\n        const cart = toCartesian(worldX, worldY);\r\n        const gx = Math.floor(cart.x / TILE_SIZE) * TILE_SIZE;\r\n        const gy = Math.floor(cart.y / TILE_SIZE) * TILE_SIZE;\r\n        const def = BUILDINGS[this.previewBuildingType];\r\n        const cx = gx + def.width / 2;\r\n        const cy = gy + def.height / 2;\r\n\r\n        const iso = toIso(cx, cy);\r\n        this.previewBuilding.setPosition(iso.x, iso.y);\r\n        this.previewBuilding.setDepth(Number.MAX_VALUE - 100);\r\n\r\n        const isValid = this.checkBuildValidity(cx, cy, this.previewBuildingType);\r\n        const color = isValid ? 0x00ff00 : 0xff0000;\r\n\r\n        const graphics = this.previewBuilding.getAt(0) as Phaser.GameObjects.Graphics;\r\n        graphics.clear();\r\n\r\n        if (def.effectRadius) {\r\n            graphics.lineStyle(2, 0xffd700, 0.8);\r\n            graphics.strokeEllipse(0, 0, def.effectRadius * 2, def.effectRadius);\r\n            graphics.fillStyle(0xffd700, 0.1);\r\n            graphics.fillEllipse(0, 0, def.effectRadius * 2, def.effectRadius);\r\n        }\r\n\r\n        this.treeHighlightGraphics.clear();\r\n        this.updateHighlights(cx, cy, def);\r\n\r\n        this.scene.entityFactory.drawIsoBuilding(graphics, def, color, 0.5);\r\n    }\r\n\r\n    private updateHighlights(cx: number, cy: number, def: BuildingDef) {\r\n        if (this.previewBuildingType === BuildingType.LUMBER_CAMP) {\r\n            const range = def.effectRadius || 200;\r\n            this.scene.trees.getChildren().forEach((t) => {\r\n                const tx = (t as Phaser.GameObjects.Image).x;\r\n                const ty = (t as Phaser.GameObjects.Image).y;\r\n                if (Phaser.Math.Distance.Between(cx, cy, tx, ty) <= range) {\r\n                    const isoT = toIso(tx, ty);\r\n                    this.treeHighlightGraphics.lineStyle(2, 0x4ade80, 0.8);\r\n                    this.treeHighlightGraphics.strokeCircle(isoT.x, isoT.y, 15);\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    public tryBuild(worldX: number, worldY: number) {\r\n        if (!this.previewBuildingType) return;\r\n\r\n        const cart = toCartesian(worldX, worldY);\r\n        const gx = Math.floor(cart.x / TILE_SIZE) * TILE_SIZE;\r\n        const gy = Math.floor(cart.y / TILE_SIZE) * TILE_SIZE;\r\n        const def = BUILDINGS[this.previewBuildingType];\r\n        const cx = gx + def.width / 2;\r\n        const cy = gy + def.height / 2;\r\n\r\n        if (this.checkBuildValidity(cx, cy, this.previewBuildingType)) {\r\n            this.scene.entityFactory.spawnBuilding(this.previewBuildingType, cx, cy);\r\n\r\n            // Juice: Screen shake (subtle)\r\n            this.scene.cameras.main.shake(80, 0.003);\r\n\r\n            // Juice: Dust particles poof\r\n            const iso = toIso(cx, cy);\r\n            this.emitDustParticles(iso.x, iso.y, def.width);\r\n\r\n            this.scene.resources.wood -= def.cost.wood;\r\n            this.scene.resources.food -= def.cost.food;\r\n            this.scene.resources.gold -= def.cost.gold;\r\n\r\n            if (this.previewBuildingType === BuildingType.HOUSE) {\r\n                this.scene.entityFactory.spawnUnit(UnitType.VILLAGER, cx + 30, cy + 30);\r\n                this.scene.feedbackSystem.showFloatingText(cx, cy, \"Peasant spawned!\", \"#00ff00\");\r\n            }\r\n\r\n\r\n            this.markTerritoryDirty();\r\n            this.scene.economySystem.updateStats();\r\n        }\r\n    }\r\n\r\n    private checkBuildValidity(x: number, y: number, type: BuildingType): boolean {\r\n        const def = BUILDINGS[type];\r\n\r\n        if (this.scene.resources.wood < def.cost.wood || this.scene.resources.food < def.cost.food || this.scene.resources.gold < def.cost.gold) {\r\n            return false;\r\n        }\r\n\r\n        let inTerritory = false;\r\n        this.scene.buildings.getChildren().forEach((b) => {\r\n            const bDef = b.getData('def') as BuildingDef;\r\n            if (bDef.territoryRadius) {\r\n                const dist = Phaser.Math.Distance.Between(x, y, (b as Phaser.GameObjects.Image).x, (b as Phaser.GameObjects.Image).y);\r\n                if (dist <= bDef.territoryRadius) inTerritory = true;\r\n            }\r\n        });\r\n        if (!inTerritory && this.scene.buildings.getLength() > 0) return false;\r\n\r\n        const bounds = new Phaser.Geom.Rectangle(x - def.width / 2, y - def.height / 2, def.width, def.height);\r\n        let overlaps = false;\r\n        this.scene.buildings.getChildren().forEach((b) => {\r\n            if (Phaser.Geom.Intersects.RectangleToRectangle(bounds, (b as Phaser.GameObjects.Image).getBounds())) {\r\n                overlaps = true;\r\n            }\r\n        });\r\n        if (overlaps) return false;\r\n\r\n        let treeOverlap = false;\r\n        this.scene.trees.getChildren().forEach((t) => {\r\n            if (bounds.contains((t as Phaser.GameObjects.Image).x, (t as Phaser.GameObjects.Image).y)) treeOverlap = true;\r\n        });\r\n        if (treeOverlap) return false;\r\n\r\n        return true;\r\n    }\r\n\r\n    public handleDemolishHover(pointer: Phaser.Input.Pointer) {\r\n        this.scene.buildings.getChildren().forEach((b) => {\r\n            const visual = (b as any).visual as Phaser.GameObjects.Container; // eslint-disable-line @typescript-eslint/no-explicit-any\r\n            if (visual) {\r\n                const highlight = visual.getData('demolishHighlight') as Phaser.GameObjects.Graphics;\r\n                if (highlight) {\r\n                    highlight.destroy();\r\n                    visual.setData('demolishHighlight', null);\r\n                }\r\n            }\r\n        });\r\n\r\n        const targets = this.scene.input.hitTestPointer(pointer);\r\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n        const buildingVisual = targets.find((obj: any) => obj.getData && obj.getData('building')) as Phaser.GameObjects.Container | undefined;\r\n\r\n        if (buildingVisual) {\r\n            const b = buildingVisual.getData('building');\r\n            if (b) {\r\n                // Fix: Only allow demolishing player buildings (owner 0)\r\n                const owner = b.getData('owner');\r\n                if (owner === 0) {\r\n                    const def = b.getData('def') as BuildingDef;\r\n                    const highlight = this.scene.add.graphics();\r\n                    this.scene.entityFactory.drawIsoBuilding(highlight, def, 0xff0000, 0.5);\r\n                    buildingVisual.add(highlight);\r\n                    buildingVisual.setData('demolishHighlight', highlight);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public handleDemolishClick(pointer: Phaser.Input.Pointer) {\r\n        const targets = this.scene.input.hitTestPointer(pointer);\r\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n        const buildingVisual = targets.find((obj: any) => obj.getData && obj.getData('building'));\r\n        if (buildingVisual) {\r\n            const b = buildingVisual.getData('building');\r\n            // Fix: Security check before demolition\r\n            const owner = b.getData('owner');\r\n            if (owner === 0) {\r\n                this.demolishBuilding(b);\r\n            }\r\n        }\r\n    }\r\n\r\n    private demolishBuilding(b: Phaser.GameObjects.GameObject) {\r\n        const def = b.getData('def') as BuildingDef;\r\n        const owner = b.getData('owner');\r\n\r\n        if (def.cost.wood > 0) this.scene.resources.wood += Math.floor(def.cost.wood * 0.75);\r\n\r\n        // FIX: Only reduce maxPopulation if it was a player building\r\n        if (owner === 0 && def.populationBonus) this.scene.maxPopulation -= def.populationBonus;\r\n        if (owner === 0 && def.happinessBonus) this.scene.happiness -= def.happinessBonus;\r\n\r\n        const worker = b.getData('assignedWorker');\r\n        if (worker) {\r\n            worker.state = UnitState.IDLE;\r\n            worker.jobBuilding = null;\r\n            worker.path = null;\r\n            worker.body.setVelocity(0, 0);\r\n        }\r\n\r\n        const logic = b as Phaser.GameObjects.Rectangle;\r\n        this.scene.pathfinder.markGrid(logic.x, logic.y, def.width, def.height, false);\r\n\r\n        // Explosion Effect\r\n        const iso = toIso(logic.x, logic.y);\r\n        this.emitExplosionParticles(iso.x, iso.y, def.width);\r\n\r\n        const visual = (b as any).visual;\r\n        if (visual) visual.destroy();\r\n        b.destroy();\r\n\r\n        if (this.scene.inputManager.selectedBuilding === b) {\r\n            this.scene.inputManager.deselectBuilding();\r\n        }\r\n\r\n        this.markTerritoryDirty();\r\n        this.scene.economySystem.updateStats();\r\n    }\r\n\r\n    public emitExplosionParticles(isoX: number, isoY: number, buildingWidth: number) {\r\n        // Larger, more dramatic explosion for demolition/destruction\r\n        const count = 30;\r\n        const emitter = this.scene.add.particles(isoX, isoY, 'smoke', {\r\n            speed: { min: 100, max: 200 },\r\n            angle: { min: 0, max: 360 },\r\n            scale: { start: 0.5, end: 0 },\r\n            alpha: { start: 1, end: 0 },\r\n            lifespan: 1200,\r\n            gravityY: -50,\r\n            blendMode: 'ADD',\r\n            emitting: false\r\n        });\r\n        emitter.setDepth(Number.MAX_VALUE - 5);\r\n\r\n        // Fire burst\r\n        const fireEmitter = this.scene.add.particles(isoX, isoY, 'flare', {\r\n            speed: { min: 50, max: 150 },\r\n            angle: { min: 0, max: 360 },\r\n            scale: { start: 0.3, end: 0 },\r\n            alpha: { start: 0.8, end: 0 },\r\n            tint: 0xff4500, // Orange-Red fire color\r\n            lifespan: 800,\r\n            blendMode: 'ADD',\r\n            emitting: false\r\n        });\r\n        fireEmitter.setDepth(Number.MAX_VALUE - 5);\r\n\r\n        emitter.explode(count);\r\n        fireEmitter.explode(20);\r\n\r\n        // Shake camera for impact\r\n        this.scene.cameras.main.shake(150, 0.005);\r\n\r\n        this.scene.time.delayedCall(1500, () => {\r\n            emitter.destroy();\r\n            fireEmitter.destroy();\r\n        });\r\n    }\r\n\r\n    private handleDemolishSelected() {\r\n        const selected = this.scene.inputManager.selectedBuilding;\r\n        if (!selected) return;\r\n\r\n        // Security check\r\n        const owner = selected.getData('owner');\r\n        if (owner === 0) {\r\n            this.demolishBuilding(selected);\r\n        }\r\n    }\r\n\r\n    private handleRegrowForest() {\r\n        const b = this.scene.inputManager.selectedBuilding as Phaser.GameObjects.Rectangle;\r\n        if (!b) return;\r\n\r\n        const def = b.getData('def') as BuildingDef;\r\n        if (def.type !== BuildingType.LUMBER_CAMP) return;\r\n\r\n        const cost = 50;\r\n        if (this.scene.resources.wood < cost) {\r\n            this.scene.feedbackSystem.showFloatingText(b.x, b.y, \"Not enough wood!\", \"#ff0000\");\r\n            return;\r\n        }\r\n\r\n\r\n        this.scene.resources.wood -= cost;\r\n\r\n        let regrownCount = 0;\r\n        this.scene.trees.getChildren().forEach((tObj: Phaser.GameObjects.GameObject) => {\r\n            const t = tObj as any;\r\n            if (t.getData('isChopped')) {\r\n                if (Phaser.Math.Distance.Between(b.x, b.y, t.x, t.y) < (def.effectRadius || 200)) {\r\n                    this.scene.entityFactory.updateTreeVisual(t, false);\r\n                    regrownCount++;\r\n                }\r\n            }\r\n        });\r\n\r\n        if (regrownCount > 0) {\r\n            this.scene.feedbackSystem.showFloatingText(b.x, b.y, \"Forest Regrown!\", \"#4ade80\");\r\n            this.scene.economySystem.updateStats();\r\n        } else {\r\n            this.scene.feedbackSystem.showFloatingText(b.x, b.y, \"No stumps nearby.\", \"#ffffff\");\r\n            this.scene.resources.wood += cost;\r\n        }\r\n\r\n    }\r\n\r\n    private drawTerritory() {\r\n        this.territoryGraphics.clear();\r\n        this.scene.buildings.getChildren().forEach((bObj: Phaser.GameObjects.GameObject) => {\r\n            const b = bObj as Phaser.GameObjects.Rectangle;\r\n            const def = b.getData('def') as BuildingDef;\r\n            const iso = toIso(b.x, b.y);\r\n            if (def.territoryRadius) {\r\n                const color = this.scene.getFactionColor(b.getData('owner'));\r\n                this.territoryGraphics.fillStyle(color, 0.1);\r\n                this.territoryGraphics.lineStyle(1, color, 0.3);\r\n                this.territoryGraphics.fillEllipse(iso.x, iso.y, def.territoryRadius * 2, def.territoryRadius);\r\n                this.territoryGraphics.strokeEllipse(iso.x, iso.y, def.territoryRadius * 2, def.territoryRadius);\r\n            }\r\n            if (def.effectRadius) {\r\n                this.territoryGraphics.lineStyle(2, 0xffd700, 0.3);\r\n                this.territoryGraphics.strokeEllipse(iso.x, iso.y, def.effectRadius * 2, def.effectRadius);\r\n            }\r\n        });\r\n    }\r\n\r\n    public emitDustParticles(isoX: number, isoY: number, buildingWidth: number) {\r\n        // Smoke poof from 8 points around building - like building dropped from sky\r\n        const offset = buildingWidth * 0.45;\r\n        const diagOffset = offset * 0.7;\r\n        const particlesPerPoint = 5;\r\n\r\n        // 8 emission points: 4 cardinal + 4 diagonal corners\r\n        const emissionPoints = [\r\n            // Cardinal directions\r\n            { x: isoX - offset, y: isoY, angle: 180 },           // Left\r\n            { x: isoX + offset, y: isoY, angle: 0 },             // Right  \r\n            { x: isoX, y: isoY - offset * 0.5, angle: 270 },     // Top\r\n            { x: isoX, y: isoY + offset * 0.5, angle: 90 },      // Bottom\r\n            // Diagonal corners\r\n            { x: isoX - diagOffset, y: isoY - diagOffset * 0.5, angle: 225 }, // Top-left\r\n            { x: isoX + diagOffset, y: isoY - diagOffset * 0.5, angle: 315 }, // Top-right\r\n            { x: isoX - diagOffset, y: isoY + diagOffset * 0.5, angle: 135 }, // Bottom-left\r\n            { x: isoX + diagOffset, y: isoY + diagOffset * 0.5, angle: 45 },  // Bottom-right\r\n        ];\r\n\r\n        emissionPoints.forEach(point => {\r\n            const emitter = this.scene.add.particles(point.x, point.y, 'smoke', {\r\n                speed: { min: 40, max: 80 },\r\n                angle: { min: point.angle - 25, max: point.angle + 25 }, // Horizontal spread\r\n                scale: { start: 0.08, end: 0.18 },\r\n                alpha: { start: 0.65, end: 0 },\r\n                lifespan: 900,\r\n                gravityY: 0, // No initial gravity\r\n                accelerationY: -60, // Curves upward over time - billowing effect!\r\n                rotate: { min: -90, max: 90 },\r\n                emitting: false\r\n            });\r\n            emitter.setDepth(Number.MAX_VALUE - 10);\r\n            emitter.explode(particlesPerPoint);\r\n\r\n            this.scene.time.delayedCall(1100, () => emitter.destroy());\r\n        });\r\n    }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\LGSM228\\CivStrategy\\game\\systems\\CullingSystem.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":76,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":76,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2995,2998],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2995,2998],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":81,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":81,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3285,3288],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3285,3288],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":111,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":111,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4619,4622],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4619,4622],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":118,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":118,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4969,4972],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4969,4972],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":122,"column":108,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":122,"endColumn":111,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5454,5457],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5454,5457],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":122,"column":127,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":122,"endColumn":130,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5473,5476],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5473,5476],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":125,"column":106,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":125,"endColumn":109,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5687,5690],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5687,5690],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":125,"column":124,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":125,"endColumn":127,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5705,5708],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5705,5708],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\LGSM228\\CivStrategy\\game\\systems\\EconomySystem.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":246,"column":61,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":246,"endColumn":64,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12320,12323],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12320,12323],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":166,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":166,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7775,7778],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7775,7778],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":234,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":234,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11371,11374],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11371,11374],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\r\nimport Phaser from 'phaser';\r\nimport { MainScene } from '../MainScene';\r\nimport { BuildingType, BuildingDef, UnitState, UnitType, GameStats, ResourceRates } from '../../types';\r\nimport { EVENTS } from '../../constants';\r\n\r\ninterface GameUnit extends Phaser.GameObjects.Image {\r\n    unitType: UnitType;\r\n    state: UnitState;\r\n    jobBuilding?: Phaser.GameObjects.GameObject;\r\n    path?: Phaser.Math.Vector2[];\r\n    pathStep?: number;\r\n}\r\n\r\nexport class EconomySystem {\r\n    private scene: MainScene;\r\n    private lastRates: ResourceRates = { wood: 0, food: 0, gold: 0, foodConsumption: 0 };\r\n    private lastHappinessChange: number = 0;\r\n\r\n    constructor(scene: MainScene) {\r\n        this.scene = scene;\r\n    }\r\n\r\n    public tickPopulation() {\r\n        // Only manage Player population (Owner 0)\r\n        if (this.scene.population < this.scene.maxPopulation && this.scene.happiness > 50) {\r\n            const houses = this.scene.buildings.getChildren().filter((b) =>\r\n                b.getData('def').type === BuildingType.HOUSE && b.getData('owner') === 0\r\n            ) as Phaser.GameObjects.Rectangle[];\r\n\r\n            let spawnSource = null;\r\n            if (houses.length > 0) {\r\n                spawnSource = houses[Phaser.Math.Between(0, houses.length - 1)];\r\n            } else {\r\n                const townCenters = this.scene.buildings.getChildren().filter((b) =>\r\n                    b.getData('def').type === BuildingType.TOWN_CENTER && b.getData('owner') === 0\r\n                ) as Phaser.GameObjects.Rectangle[];\r\n                if (townCenters.length > 0) spawnSource = townCenters[0];\r\n            }\r\n\r\n            if (spawnSource) {\r\n                const offsetX = Phaser.Math.Between(-30, 30);\r\n                const offsetY = Phaser.Math.Between(-30, 30);\r\n                const spawnX = spawnSource.x + (offsetX >= 0 ? 50 : -50) + offsetX;\r\n                const spawnY = spawnSource.y + (offsetY >= 0 ? 50 : -50) + offsetY;\r\n\r\n                this.scene.entityFactory.spawnUnit(UnitType.VILLAGER, spawnX, spawnY, 0);\r\n                this.scene.events.emit('message', \"A new peasant has arrived.\");\r\n            }\r\n        }\r\n    }\r\n\r\n    public assignJobs() {\r\n        const vacantBuildings = this.scene.buildings.getChildren().filter((b) => {\r\n            const def = b.getData('def') as BuildingDef;\r\n            const assignedWorker = b.getData('assignedWorker');\r\n            return def.workerNeeds && !assignedWorker;\r\n        });\r\n\r\n        const idleVillagers = this.scene.units.getChildren().filter((u) => {\r\n            const unit = u as unknown as GameUnit;\r\n            return (unit.unitType === UnitType.VILLAGER) && (unit.state === UnitState.IDLE || unit.state === UnitState.MOVING_TO_RALLY);\r\n        }) as Phaser.GameObjects.GameObject[];\r\n\r\n        for (const building of vacantBuildings) {\r\n            if (idleVillagers.length === 0) break;\r\n\r\n            const b = building as Phaser.GameObjects.Image;\r\n            const buildingOwner = b.getData('owner');\r\n\r\n            let closestWorker: Phaser.GameObjects.GameObject | null = null;\r\n            let minDist = Number.MAX_VALUE;\r\n            let workerIndex = -1;\r\n\r\n            for (let i = 0; i < idleVillagers.length; i++) {\r\n                const u = idleVillagers[i] as Phaser.GameObjects.Image;\r\n\r\n                // STRICT OWNERSHIP CHECK: Only assign villagers to buildings of the same owner\r\n                if (u.getData('owner') !== buildingOwner) continue;\r\n\r\n                const dist = Phaser.Math.Distance.Between(b.x, b.y, u.x, u.y);\r\n                if (dist < minDist) {\r\n                    minDist = dist;\r\n                    closestWorker = u;\r\n                    workerIndex = i;\r\n                }\r\n            }\r\n\r\n            if (closestWorker) {\r\n                idleVillagers.splice(workerIndex, 1);\r\n                b.setData('assignedWorker', closestWorker);\r\n                (closestWorker as unknown as GameUnit).state = UnitState.MOVING_TO_WORK;\r\n                (closestWorker as unknown as GameUnit).jobBuilding = b;\r\n\r\n                const path = this.scene.pathfinder.findPath(new Phaser.Math.Vector2((closestWorker as unknown as GameUnit).x, (closestWorker as unknown as GameUnit).y), new Phaser.Math.Vector2(b.x, b.y));\r\n                if (path) {\r\n                    (closestWorker as unknown as GameUnit).path = path;\r\n                    (closestWorker as unknown as GameUnit).pathStep = 0;\r\n                }\r\n            }\r\n        }\r\n\r\n        // Re-filter idle villagers to those who are still truly idle and job-less\r\n        const remainingIdle = this.scene.units.getChildren().filter((u) => {\r\n            const unit = u as unknown as GameUnit;\r\n            return unit.unitType === UnitType.VILLAGER && unit.state === UnitState.IDLE && !unit.jobBuilding;\r\n        });\r\n\r\n        if (remainingIdle.length > 0) {\r\n            const allBonfires = this.scene.buildings.getChildren().filter((b) => b.getData('def').type === BuildingType.BONFIRE) as Phaser.GameObjects.Rectangle[];\r\n\r\n            if (allBonfires.length > 0) {\r\n                remainingIdle.forEach((u) => {\r\n                    const owner = u.getData('owner');\r\n                    // Filter bonfires by OWNER\r\n                    const myBonfires = allBonfires.filter((b) => b.getData('owner') === owner);\r\n\r\n                    if (myBonfires.length > 0) {\r\n                        let closestBonfire = myBonfires[0];\r\n                        let minDistance = Number.MAX_VALUE;\r\n                        for (const bonfire of myBonfires) {\r\n                            const d = Phaser.Math.Distance.Between((u as Phaser.GameObjects.Image).x, (u as Phaser.GameObjects.Image).y, bonfire.x, bonfire.y);\r\n                            if (d < minDistance) {\r\n                                minDistance = d;\r\n                                closestBonfire = bonfire;\r\n                            }\r\n                        }\r\n                        const rallyPoint = closestBonfire;\r\n                        // Only move if far away\r\n                        if (minDistance > 100) {\r\n                            (u as unknown as GameUnit).state = UnitState.MOVING_TO_RALLY;\r\n                            const angle = Math.random() * Math.PI * 2;\r\n                            const r = Math.random() * 60 + 40;\r\n                            const destX = rallyPoint.x + Math.cos(angle) * r;\r\n                            const destY = rallyPoint.y + Math.sin(angle) * r;\r\n                            const path = this.scene.pathfinder.findPath(new Phaser.Math.Vector2((u as Phaser.GameObjects.Image).x, (u as Phaser.GameObjects.Image).y), new Phaser.Math.Vector2(destX, destY));\r\n                            if (path) {\r\n                                (u as unknown as GameUnit).path = path;\r\n                                (u as unknown as GameUnit).pathStep = 0;\r\n                            }\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n        }\r\n    }\r\n\r\n    public tickEconomy() {\r\n        const isLowHappiness = this.scene.happiness < 50;\r\n        const efficiency = isLowHappiness ? 0.5 : 1.0;\r\n        const taxGoldPerPop = this.scene.taxRate;\r\n\r\n        let foodGen = 0;\r\n        let woodGen = 0;\r\n\r\n        // Base Commerce for Player\r\n        let goldGen = Math.floor((this.scene.population * (0.5 + taxGoldPerPop)) * efficiency);\r\n\r\n        const harvestedTrees = new Set<Phaser.GameObjects.GameObject>();\r\n\r\n        this.scene.buildings.getChildren().forEach((b) => {\r\n            // STRICT OWNERSHIP CHECK: Only process PLAYER buildings for player economy\r\n            if (b.getData('owner') !== 0) return;\r\n\r\n            const def = b.getData('def') as BuildingDef;\r\n            const visual = (b as any).visual as Phaser.GameObjects.Container; // eslint-disable-line @typescript-eslint/no-explicit-any\r\n            const vacantIcon = visual.getData('vacantIcon') as Phaser.GameObjects.Text;\r\n            const noResIcon = visual.getData('noResIcon') as Phaser.GameObjects.Text;\r\n\r\n            let isWorking = true;\r\n            let productionAmount = 0;\r\n            let productionType = '';\r\n\r\n            if (def.workerNeeds) {\r\n                const worker = b.getData('assignedWorker');\r\n                if (worker && worker.state === UnitState.WORKING) {\r\n                    if (vacantIcon) vacantIcon.visible = false;\r\n                } else {\r\n                    isWorking = false;\r\n                    if (vacantIcon) vacantIcon.visible = true;\r\n                }\r\n            }\r\n\r\n            if (def.type === BuildingType.TOWN_CENTER) {\r\n                goldGen += Math.floor(2 * efficiency);\r\n                isWorking = true;\r\n            }\r\n\r\n            if (isWorking) {\r\n                if (def.type === BuildingType.FARM) {\r\n                    let gain = 5;\r\n                    const isFertile = this.scene.fertileZones.some(zone => zone.contains((b as Phaser.GameObjects.Image).x, (b as Phaser.GameObjects.Image).y));\r\n                    if (isFertile) gain = Math.floor(gain * 1.5);\r\n                    gain = Math.floor(gain * efficiency);\r\n                    foodGen += gain;\r\n                    productionAmount = gain;\r\n                    productionType = 'Food';\r\n                }\r\n\r\n                if (def.type === BuildingType.LUMBER_CAMP && def.effectRadius) {\r\n                    let treesNearby = 0;\r\n                    // Optimize: Use Spatial Partitioning\r\n                    const candidates = this.scene.treeSpatialHash.query((b as Phaser.GameObjects.Image).x, (b as Phaser.GameObjects.Image).y, def.effectRadius);\r\n\r\n                    for (const t of candidates) {\r\n                        // Cast t to Image to access x,y\r\n                        const tree = t as Phaser.GameObjects.Image;\r\n                        if (Phaser.Math.Distance.Between((b as Phaser.GameObjects.Image).x, (b as Phaser.GameObjects.Image).y, tree.x, tree.y) < def.effectRadius) {\r\n                            const isChopped = tree.getData('isChopped');\r\n                            if (!isChopped && !harvestedTrees.has(tree)) {\r\n                                treesNearby++;\r\n                                harvestedTrees.add(tree);\r\n                                if (Math.random() < 0.1) {\r\n                                    this.scene.entityFactory.updateTreeVisual(tree, true);\r\n                                    // if (this.scene.minimapSystem) this.scene.minimapSystem.refreshStaticLayer();\r\n                                    this.scene.feedbackSystem.showFloatingText(tree.x, tree.y, \"Chopped!\", \"#a0522d\");\r\n                                }\r\n\r\n                            }\r\n                        }\r\n                    }\r\n                    if (noResIcon) noResIcon.visible = (treesNearby === 0);\r\n                    let gain = Math.min(treesNearby * 2, 12);\r\n                    gain = Math.floor(gain * efficiency);\r\n                    woodGen += gain;\r\n                    if (gain > 0) {\r\n                        productionAmount = gain;\r\n                        productionType = 'Wood';\r\n                    }\r\n                }\r\n\r\n                if (def.type === BuildingType.HUNTERS_LODGE && def.effectRadius) {\r\n                    const animals = this.scene.units.getChildren().filter((u) => {\r\n                        return (u as any).unitType === UnitType.ANIMAL && Phaser.Math.Distance.Between((b as Phaser.GameObjects.Image).x, (b as Phaser.GameObjects.Image).y, (u as Phaser.GameObjects.Image).x, (u as Phaser.GameObjects.Image).y) < def.effectRadius!; // eslint-disable-line @typescript-eslint/no-explicit-any\r\n                    });\r\n                    const animalsNearby = animals.length;\r\n                    if (noResIcon) noResIcon.visible = (animalsNearby === 0);\r\n                    if (animalsNearby > 0) {\r\n                        let gain = 20;\r\n                        gain = Math.floor(gain * efficiency);\r\n                        foodGen += gain;\r\n                        productionAmount = gain;\r\n                        productionType = 'Food';\r\n                        if (Math.random() < 0.20) {\r\n                            const victim = animals[Phaser.Math.Between(0, animalsNearby - 1)];\r\n                            const victimVisual = (victim as any).visual;\r\n                            if (victimVisual) victimVisual.destroy();\r\n                            victim.destroy();\r\n                            this.scene.feedbackSystem.showFloatingText(b.x, b.y - 30, \"Depleted!\", \"#ef4444\");\r\n                        }\r\n\r\n                    }\r\n                }\r\n            }\r\n            if (productionAmount > 0) {\r\n                this.scene.feedbackSystem.showFloatingResource((b as Phaser.GameObjects.Image).x, (b as Phaser.GameObjects.Image).y, productionAmount, productionType);\r\n            }\r\n\r\n        });\r\n\r\n        if (goldGen > 0) {\r\n            const tcs = this.scene.buildings.getChildren().filter((b) =>\r\n                b.getData('def').type === BuildingType.TOWN_CENTER && b.getData('owner') === 0\r\n            ) as Phaser.GameObjects.Rectangle[];\r\n            if (tcs.length > 0) {\r\n                this.scene.feedbackSystem.showFloatingResource(tcs[0].x, tcs[0].y, goldGen, 'Gold');\r\n            }\r\n\r\n        }\r\n\r\n        const foodConsumed = this.scene.population * 1;\r\n        this.lastRates = { wood: woodGen, food: foodGen, gold: goldGen, foodConsumption: foodConsumed };\r\n        this.scene.resources.food += foodGen;\r\n        this.scene.resources.wood += woodGen;\r\n        this.scene.resources.gold += goldGen;\r\n        this.scene.resources.food -= foodConsumed;\r\n        if (this.scene.resources.food < 0) this.scene.resources.food = 0;\r\n\r\n        let happinessChange = 0;\r\n        const isStarving = this.scene.resources.food === 0 && foodConsumed > 0;\r\n        if (isStarving) { happinessChange -= 5; } else { happinessChange += 1; }\r\n        if (this.scene.population > this.scene.maxPopulation) { happinessChange -= 2; }\r\n        const taxImpact = [1, 0, -1, -3, -6, -10];\r\n        happinessChange += (taxImpact[this.scene.taxRate] || 0);\r\n\r\n        // Count ONLY player parks\r\n        const parks = this.scene.buildings.getChildren().filter((b) =>\r\n            b.getData('def').type === BuildingType.SMALL_PARK && b.getData('owner') === 0\r\n        );\r\n        happinessChange += parks.length;\r\n\r\n        this.scene.happiness += happinessChange;\r\n        this.scene.happiness = Phaser.Math.Clamp(this.scene.happiness, 0, 100);\r\n        this.lastHappinessChange = happinessChange;\r\n        this.updateStats();\r\n    }\r\n\r\n    public updateStats() {\r\n        const remainingTreaty = Math.max(0, this.scene.treatyLength - this.scene.gameTime);\r\n\r\n        const stats: GameStats = {\r\n            population: this.scene.population,\r\n            maxPopulation: this.scene.maxPopulation,\r\n            happiness: this.scene.happiness,\r\n            happinessChange: this.lastHappinessChange,\r\n            resources: { ...this.scene.resources },\r\n            rates: this.lastRates,\r\n            taxRate: this.scene.taxRate,\r\n            mapMode: this.scene.mapMode,\r\n            peacefulMode: this.scene.peacefulMode,\r\n            treatyTimeRemaining: remainingTreaty\r\n        };\r\n        this.scene.game.events.emit(EVENTS.UPDATE_STATS, stats);\r\n    }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\LGSM228\\CivStrategy\\game\\systems\\EnemyAISystem.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":144,"column":143,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":144,"endColumn":146,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4971,4974],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4971,4974],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\LGSM228\\CivStrategy\\game\\systems\\EntityFactory.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":119,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":119,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5750,5753],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5750,5753],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":192,"column":59,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":192,"endColumn":62,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9558,9561],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9558,9561],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":192,"column":78,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":192,"endColumn":81,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9577,9580],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9577,9580],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":196,"column":46,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":196,"endColumn":49,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9833,9836],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9833,9836],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":196,"column":65,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":196,"endColumn":68,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9852,9855],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9852,9855],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":220,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":220,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10882,10885],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10882,10885],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":83,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":83,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3827,3830],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3827,3830],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":90,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":90,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4263,4266],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4263,4266],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":91,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":91,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4384,4387],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4384,4387],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":107,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":107,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5045,5048],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5045,5048],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":147,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":147,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6868,6871],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6868,6871],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":148,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":148,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6966,6969],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6966,6969],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":154,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":154,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7282,7285],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7282,7285],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":155,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":155,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7387,7390],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7387,7390],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":156,"column":22,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":156,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7511,7514],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7511,7514],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":162,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":162,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7868,7871],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7868,7871],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":180,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":180,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8775,8778],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8775,8778],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":6,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\r\nimport Phaser from 'phaser';\r\nimport { MainScene } from '../MainScene';\r\nimport { BuildingType, UnitType, UnitState, BuildingDef, FactionType } from '../../types';\r\nimport { BUILDINGS, UNIT_STATS } from '../../constants';\r\nimport { toIso } from '../utils/iso';\r\n\r\nexport class EntityFactory {\r\n    private scene: MainScene;\r\n\r\n    constructor(scene: MainScene) {\r\n        this.scene = scene;\r\n    }\r\n\r\n    public spawnBuilding(type: BuildingType, x: number, y: number, owner: number = 0): Phaser.GameObjects.GameObject {\r\n        const def = BUILDINGS[type];\r\n        const b = this.scene.add.rectangle(x, y, def.width, def.height, 0x000000, 0);\r\n        this.scene.physics.add.existing(b, true);\r\n        b.setData('def', def);\r\n        b.setData('owner', owner);\r\n        b.setData('hp', def.maxHp);\r\n        b.setData('maxHp', def.maxHp);\r\n        this.scene.buildings.add(b);\r\n\r\n        this.scene.pathfinder.markGrid(x, y, def.width, def.height, true);\r\n\r\n        const visual = this.scene.add.container(0, 0);\r\n        const gfx = this.scene.add.graphics();\r\n        const baseColor = owner === 1 ? 0x3f3f46 : def.color; // Keep dark base for enemy buildings for contrast, or maybe subtle tint? Let's keep it but make banner colorful.\r\n        // ACTUALLY plan says \"Update the enemy banner creation to use this.scene.getFactionColor(owner)\".\r\n        // And \"Update spawnUnit to use this.scene.getFactionColor(owner)\".\r\n        // Let's stick to the plan.\r\n\r\n        let spriteUsed = false;\r\n\r\n        const setupSprite = (key: string, scaleMultiplier: number = 2.2, originY: number = 0.75) => {\r\n            if (!this.scene.textures.exists(key)) return false;\r\n            const sprite = this.scene.add.image(0, 0, key);\r\n            sprite.setOrigin(0.5, originY);\r\n            const targetWidth = def.width * scaleMultiplier;\r\n            const scale = targetWidth / sprite.width;\r\n            sprite.setScale(scale);\r\n            visual.add(sprite);\r\n            return true;\r\n        };\r\n\r\n        if (type === BuildingType.FARM) { if (setupSprite('field', 2.0, 0.5)) spriteUsed = true; }\r\n        else if (type === BuildingType.HOUSE) { if (setupSprite('house', 2.5, 0.85)) spriteUsed = true; }\r\n        else if (type === BuildingType.HUNTERS_LODGE) { if (setupSprite('lodge', 2.5, 0.75)) spriteUsed = true; }\r\n\r\n        if (!spriteUsed && owner === 0 && this.scene.faction === FactionType.ROMANS) {\r\n            if (type === BuildingType.TOWN_CENTER) { if (setupSprite('townhall', 1.5, 0.75)) spriteUsed = true; }\r\n            else if (type === BuildingType.LUMBER_CAMP) { if (setupSprite('lumber', 2.6, 0.75)) spriteUsed = true; }\r\n        }\r\n\r\n        if (!spriteUsed) {\r\n            if (type === BuildingType.BONFIRE) {\r\n                this.drawBonfire(gfx);\r\n                this.scene.tweens.add({ targets: gfx, scaleX: 1.05, scaleY: 1.05, alpha: 0.9, yoyo: true, repeat: -1, duration: 150 });\r\n            } else if (type === BuildingType.SMALL_PARK) {\r\n                this.drawPark(gfx);\r\n            } else {\r\n                this.drawIsoBuilding(gfx, def, baseColor);\r\n            }\r\n        }\r\n\r\n        if (owner === 1) {\r\n            const banner = this.scene.add.rectangle(0, -40, 16, 8, this.scene.getFactionColor(owner));\r\n            visual.add(banner);\r\n        }\r\n\r\n        if (!spriteUsed || type === BuildingType.BONFIRE || type === BuildingType.SMALL_PARK) {\r\n            const text = this.scene.add.text(0, -def.height * 0.5 - 10, def.name[0], { fontSize: '14px', color: '#ffffff' }).setOrigin(0.5);\r\n            visual.add([gfx, text]);\r\n        } else {\r\n            visual.add(gfx);\r\n        }\r\n\r\n        const hpBar = this.createHealthBar(visual, def.width, -def.height * 0.8 - 35);\r\n        visual.setData('hpBar', hpBar);\r\n\r\n        this.scene.add.existing(visual);\r\n        (b as any).visual = visual; // eslint-disable-line @typescript-eslint/no-explicit-any\r\n        const iso = toIso(x, y);\r\n        visual.setPosition(iso.x, iso.y).setDepth(iso.y);\r\n        visual.setInteractive(new Phaser.Geom.Rectangle(-def.width / 2, -def.height, def.width, def.height), Phaser.Geom.Rectangle.Contains);\r\n        visual.setData('building', b);\r\n\r\n        // Building selection method with pulsing glow effect\r\n        (b as any).setSelected = (selected: boolean) => { // eslint-disable-line @typescript-eslint/no-explicit-any\r\n            (b as any).isSelected = selected; // eslint-disable-line @typescript-eslint/no-explicit-any\r\n            const hpBar = visual.getData('hpBar') as Phaser.GameObjects.Container;\r\n            if (hpBar) hpBar.setVisible(selected || b.getData('hp') < b.getData('maxHp'));\r\n\r\n            if (selected) {\r\n                this.startGlowEffect(visual);\r\n            } else {\r\n                this.stopGlowEffect(visual);\r\n            }\r\n        };\r\n\r\n        if (owner === 0) {\r\n            if (def.populationBonus) this.scene.maxPopulation += def.populationBonus;\r\n            if (def.happinessBonus) this.scene.happiness += def.happinessBonus;\r\n        }\r\n\r\n        (b as any).takeDamage = (amount: number) => this.handleDamage(b, amount, false); // eslint-disable-line @typescript-eslint/no-explicit-any\r\n        return b;\r\n    }\r\n\r\n    public spawnUnit(type: UnitType, x: number, y: number, owner: number = 0) {\r\n        const stats = UNIT_STATS[type];\r\n        const radius = 8;\r\n        const unit = this.scene.add.circle(x, y, radius, 0x000000, 0);\r\n        this.scene.physics.add.existing(unit);\r\n        const body = unit.body as Phaser.Physics.Arcade.Body;\r\n        body.setCircle(radius);\r\n        unit.setData({ owner, unitType: type, hp: stats.maxHp, maxHp: stats.maxHp, attack: stats.attack, range: stats.range, attackSpeed: stats.attackSpeed });\r\n        (unit as any).lastAttackTime = 0;\r\n        this.scene.units.add(unit);\r\n\r\n        // Increment population for player-owned units (but not animals)\r\n        if (owner === 0 && type !== UnitType.ANIMAL) {\r\n            this.scene.population++;\r\n        }\r\n\r\n        const visual = this.scene.add.container(0, 0);\r\n        const gfx = this.scene.add.graphics();\r\n        const primaryColor = this.scene.getFactionColor(owner);\r\n\r\n        if (type === UnitType.VILLAGER) {\r\n            gfx.fillStyle(primaryColor, 1).fillEllipse(0, 0, 10, 6);\r\n            visual.add([gfx, this.scene.add.rectangle(0, -6, 4, 8, owner === 1 ? 0x18181b : 0x7CB342), this.scene.add.circle(0, -11, 2.5, 0xffcccc)]);\r\n        } else if (type === UnitType.ANIMAL) {\r\n            gfx.fillStyle(0x795548, 1).fillEllipse(0, 0, 12, 7);\r\n            visual.add(gfx);\r\n            visual.setScale(0.8);\r\n        } else {\r\n            visual.setVisible(false);\r\n        }\r\n\r\n        if (stats.squadSize === 1) {\r\n            visual.setData('hpBar', this.createHealthBar(visual, 24, -20));\r\n        }\r\n\r\n        this.scene.add.existing(visual);\r\n        (unit as any).visual = visual; // eslint-disable-line @typescript-eslint/no-explicit-any\r\n        (unit as any).unitType = type; // eslint-disable-line @typescript-eslint/no-explicit-any\r\n\r\n        // CRITICAL FIX: Make unit visual click-able for selection/targeting\r\n        visual.setInteractive(new Phaser.Geom.Circle(0, -10, 15), Phaser.Geom.Circle.Contains);\r\n        visual.setData('unit', unit);\r\n\r\n        (unit as any).state = UnitState.IDLE; // eslint-disable-line @typescript-eslint/no-explicit-any\r\n        (unit as any).setSelected = (selected: boolean) => { // eslint-disable-line @typescript-eslint/no-explicit-any\r\n            (unit as any).isSelected = selected; // eslint-disable-line @typescript-eslint/no-explicit-any\r\n            const hpBar = visual.getData('hpBar');\r\n            if (hpBar) hpBar.setVisible(selected || unit.getData('hp') < unit.getData('maxHp'));\r\n        };\r\n\r\n        if (stats.squadSize > 1) this.scene.squadSystem.createSquad(unit, type, owner);\r\n        (unit as any).takeDamage = (amount: number) => this.handleDamage(unit, amount, true); // eslint-disable-line @typescript-eslint/no-explicit-any\r\n        return unit;\r\n    }\r\n\r\n    private createHealthBar(visual: Phaser.GameObjects.Container, width: number, y: number): Phaser.GameObjects.Container {\r\n        const bar = this.scene.add.container(0, y);\r\n        const fg = this.scene.add.rectangle(-width / 2, 0, width, 2, 0x22c55e).setOrigin(0, 0.5).setName('barFill');\r\n        bar.add([this.scene.add.rectangle(0, 0, width, 4, 0x000000), fg]);\r\n        bar.setVisible(false);\r\n        visual.add(bar);\r\n        return bar;\r\n    }\r\n\r\n    private handleDamage(entity: Phaser.GameObjects.GameObject, amount: number, isUnit: boolean) {\r\n        let hp = entity.getData('hp');\r\n        const maxHp = entity.getData('maxHp');\r\n        hp -= amount;\r\n        entity.setData('hp', hp);\r\n        const visual = (entity as any).visual as Phaser.GameObjects.Container; // eslint-disable-line @typescript-eslint/no-explicit-any\r\n        if (visual && visual.getData('hpBar')) {\r\n            const hpBar = visual.getData('hpBar') as Phaser.GameObjects.Container;\r\n            hpBar.setVisible(true);\r\n            const fill = hpBar.getByName('barFill') as Phaser.GameObjects.Rectangle;\r\n            fill.scaleX = Math.max(0, hp / maxHp);\r\n            fill.fillColor = fill.scaleX < 0.3 ? 0xef4444 : 0x22c55e;\r\n        }\r\n        if (hp <= 0) {\r\n            if (isUnit) { this.scene.squadSystem.destroySquad(entity); if (entity.getData('owner') === 0) this.scene.population--; }\r\n            else {\r\n                const def = entity.getData('def');\r\n                this.scene.pathfinder.markGrid((entity as any).x, (entity as any).y, def.width, def.height, false);\r\n                if (entity.getData('owner') === 0 && def.populationBonus) this.scene.maxPopulation -= def.populationBonus;\r\n\r\n                // Trigger explosion effect\r\n                const iso = toIso((entity as any).x, (entity as any).y);\r\n                this.scene.buildingManager.emitExplosionParticles(iso.x, iso.y, def.width);\r\n            }\r\n            if (visual) visual.destroy();\r\n            entity.destroy();\r\n        }\r\n    }\r\n\r\n    public spawnTree(x: number, y: number) {\r\n        // Optimization: Use single Image instead of Container + 2 Images\r\n        // VIRTUALIZATON: Do NOT create visual here. Store data for pool.\r\n        const treeBase = this.scene.add.circle(x, y, 6, 0x000000, 0);\r\n        treeBase.setVisible(false); // Invisible, logic only\r\n        this.scene.physics.add.existing(treeBase, true);\r\n        this.scene.trees.add(treeBase);\r\n        this.scene.treeSpatialHash.insert(treeBase);\r\n\r\n        // Store visual properties for later hydration\r\n        treeBase.setData('visualScale', Phaser.Math.FloatBetween(0.8, 1.1) * 0.075);\r\n        treeBase.setData('visualTexture', 'tree');\r\n        treeBase.setData('visualOriginY', 0.95);\r\n        treeBase.setData('isChopped', false);\r\n    }\r\n\r\n    public updateTreeVisual(tree: any, isChopped: boolean) {\r\n        tree.setData('isChopped', isChopped);\r\n\r\n        // Update data\r\n        if (isChopped) {\r\n            tree.setData('visualTexture', 'stump');\r\n            tree.setData('visualScale', 0.075);\r\n            tree.setData('visualOriginY', 0.5);\r\n        } else {\r\n            tree.setData('visualTexture', 'tree');\r\n            // Keep original random scale? simplified for now\r\n            tree.setData('visualOriginY', 0.95);\r\n        }\r\n\r\n        // If currently visible (has visual), update it immediately\r\n        const visual = tree.visual as Phaser.GameObjects.Image;\r\n        if (visual) {\r\n            visual.setTexture(tree.getData('visualTexture'));\r\n            visual.setScale(tree.getData('visualScale'));\r\n            visual.setOrigin(0.5, tree.getData('visualOriginY'));\r\n        }\r\n    }\r\n\r\n    public drawIsoBuilding(gfx: Phaser.GameObjects.Graphics, def: BuildingDef, color: number, alpha = 1) {\r\n        const w = def.width, h = def.height, height = Math.min(w, h) * 0.45;\r\n        const corners = [{ x: -w / 2, y: -h / 2 }, { x: w / 2, y: -h / 2 }, { x: w / 2, y: h / 2 }, { x: -w / 2, y: h / 2 }];\r\n        const isoCorners = corners.map(c => toIso(c.x, c.y));\r\n        gfx.fillStyle(color, alpha).beginPath();\r\n        gfx.moveTo(isoCorners[0].x, isoCorners[0].y - height).lineTo(isoCorners[1].x, isoCorners[1].y - height)\r\n            .lineTo(isoCorners[2].x, isoCorners[2].y - height).lineTo(isoCorners[3].x, isoCorners[3].y - height).closePath().fillPath();\r\n        gfx.fillStyle(Phaser.Display.Color.IntegerToColor(color).darken(20).color, alpha).beginPath()\r\n            .moveTo(isoCorners[2].x, isoCorners[2].y - height).lineTo(isoCorners[1].x, isoCorners[1].y - height)\r\n            .lineTo(isoCorners[1].x, isoCorners[1].y).lineTo(isoCorners[2].x, isoCorners[2].y).closePath().fillPath();\r\n    }\r\n\r\n    private drawBonfire(gfx: Phaser.GameObjects.Graphics) {\r\n        gfx.fillStyle(0x78716c).fillEllipse(0, 0, 24, 12);\r\n        gfx.fillStyle(0xf97316, 0.8).beginPath().moveTo(-6, -6).lineTo(0, -20).lineTo(6, -6).closePath().fillPath();\r\n    }\r\n\r\n    private drawPark(gfx: Phaser.GameObjects.Graphics) {\r\n        gfx.fillStyle(0x86efac).beginPath();\r\n        const pts = [toIso(-14, -14), toIso(14, -14), toIso(14, 14), toIso(-14, 14)];\r\n        gfx.moveTo(pts[0].x, pts[0].y).lineTo(pts[1].x, pts[1].y).lineTo(pts[2].x, pts[2].y).lineTo(pts[3].x, pts[3].y).closePath().fillPath();\r\n        gfx.fillStyle(0x15803d).fillCircle(0, -4, 6);\r\n    }\r\n\r\n    private startGlowEffect(visual: Phaser.GameObjects.Container) {\r\n        // Remove any existing glow\r\n        this.stopGlowEffect(visual);\r\n\r\n        // Find all sprites/images in the container and create additive overlays\r\n        const glowOverlays: Phaser.GameObjects.Image[] = [];\r\n        visual.each((child: Phaser.GameObjects.GameObject) => {\r\n            if (child instanceof Phaser.GameObjects.Image) {\r\n                // Create a duplicate sprite on top with ADD blend mode\r\n                const overlay = this.scene.add.image(child.x, child.y, child.texture.key);\r\n                overlay.setOrigin(child.originX, child.originY);\r\n                overlay.setScale(child.scaleX, child.scaleY);\r\n                overlay.setBlendMode(Phaser.BlendModes.ADD);\r\n                overlay.setAlpha(0);\r\n                visual.add(overlay);\r\n                glowOverlays.push(overlay);\r\n            }\r\n        });\r\n\r\n        if (glowOverlays.length === 0) return;\r\n\r\n        visual.setData('glowOverlays', glowOverlays);\r\n\r\n        // Create pulsing tween on the overlay alphas\r\n        const tween = this.scene.tweens.add({\r\n            targets: glowOverlays,\r\n            alpha: { from: 0, to: 0.35 },\r\n            duration: 600,\r\n            yoyo: true,\r\n            repeat: -1,\r\n            ease: 'Sine.easeInOut'\r\n        });\r\n        visual.setData('glowTween', tween);\r\n    }\r\n\r\n    private stopGlowEffect(visual: Phaser.GameObjects.Container) {\r\n        const tween = visual.getData('glowTween') as Phaser.Tweens.Tween;\r\n        if (tween) {\r\n            tween.stop();\r\n            tween.destroy();\r\n            visual.setData('glowTween', null);\r\n        }\r\n\r\n        // Destroy overlay sprites\r\n        const glowOverlays = visual.getData('glowOverlays') as Phaser.GameObjects.Image[];\r\n        if (glowOverlays) {\r\n            glowOverlays.forEach(overlay => overlay.destroy());\r\n            visual.setData('glowOverlays', null);\r\n        }\r\n    }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\LGSM228\\CivStrategy\\game\\systems\\FeedbackSystem.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\LGSM228\\CivStrategy\\game\\systems\\FogOfWarSystem.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":140,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":140,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5373,5376],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5373,5376],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":153,"column":45,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":153,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6044,6047],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6044,6047],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\LGSM228\\CivStrategy\\game\\systems\\InfiniteMapSystem.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\LGSM228\\CivStrategy\\game\\systems\\InputManager.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":64,"column":67,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":64,"endColumn":70,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2805,2808],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2805,2808],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":106,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":106,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4480,4483],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4480,4483],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":108,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":108,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4655,4658],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4655,4658],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":120,"column":52,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":120,"endColumn":55,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5083,5086],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5083,5086],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":132,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":132,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5597,5600],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5597,5600],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":200,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":200,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8186,8189],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8186,8189],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":204,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":204,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8475,8478],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8475,8478],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":230,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":230,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9631,9634],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9631,9634],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":233,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":233,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9855,9858],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9855,9858],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":240,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":240,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10216,10219],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10216,10219],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":240,"column":51,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":240,"endColumn":54,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10240,10243],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10240,10243],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":243,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":243,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10403,10406],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10403,10406],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":243,"column":47,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":243,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10427,10430],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10427,10430],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":244,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":244,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10543,10546],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10543,10546],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":260,"column":52,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":260,"endColumn":55,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11220,11223],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11220,11223],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":283,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":283,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12121,12124],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12121,12124],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":292,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":292,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12490,12493],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12490,12493],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":305,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":305,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12908,12911],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12908,12911],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":305,"column":87,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":305,"endColumn":90,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12952,12955],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12952,12955],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":306,"column":49,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":306,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13084,13087],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13084,13087],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\LGSM228\\CivStrategy\\game\\systems\\MapGenerationSystem.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'MAP_SIZES' is defined but never used. Allowed unused vars must match /^_/u.","line":3,"column":21,"nodeType":null,"messageId":"unusedVar","endLine":3,"endColumn":30}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import Phaser from 'phaser';\r\nimport { MainScene } from '../MainScene';\r\nimport { TILE_SIZE, MAP_SIZES } from '../../constants';\r\nimport { toIso } from '../utils/iso';\r\nimport { UnitType } from '../../types';\r\n\r\nexport class MapGenerationSystem {\r\n    private scene: MainScene;\r\n\r\n    constructor(scene: MainScene) {\r\n        this.scene = scene;\r\n    }\r\n\r\n    createEnvironment() {\r\n        const p1 = toIso(0, 0);\r\n        const p2 = toIso(this.scene.mapWidth, 0);\r\n        const p3 = toIso(this.scene.mapWidth, this.scene.mapHeight);\r\n        const p4 = toIso(0, this.scene.mapHeight);\r\n\r\n        const border = this.scene.add.graphics();\r\n        border.lineStyle(8, 0x000000, 0.4);\r\n        border.beginPath();\r\n        border.moveTo(p1.x, p1.y);\r\n        border.lineTo(p2.x, p2.y);\r\n        border.lineTo(p3.x, p3.y);\r\n        border.lineTo(p4.x, p4.y);\r\n        border.closePath();\r\n        border.strokePath();\r\n        border.setDepth(-19000);\r\n\r\n        const grid = this.scene.add.graphics();\r\n        grid.lineStyle(2, 0x000000, 0.15);\r\n        const gridSpacing = TILE_SIZE * 4;\r\n        for (let x = 0; x <= this.scene.mapWidth; x += gridSpacing) {\r\n            const start = toIso(x, 0);\r\n            const end = toIso(x, this.scene.mapHeight);\r\n            grid.moveTo(start.x, start.y);\r\n            grid.lineTo(end.x, end.y);\r\n        }\r\n        for (let y = 0; y <= this.scene.mapHeight; y += gridSpacing) {\r\n            const start = toIso(0, y);\r\n            const end = toIso(this.scene.mapWidth, y);\r\n            grid.moveTo(start.x, start.y);\r\n            grid.lineTo(end.x, end.y);\r\n        }\r\n        grid.strokePath();\r\n        grid.setDepth(-9999);\r\n    }\r\n\r\n    generateFertileZones() {\r\n        const zoneCount = Math.floor((this.scene.mapWidth * this.scene.mapHeight) / (500 * 500));\r\n        for (let i = 0; i < zoneCount; i++) {\r\n            const x = Phaser.Math.Between(150, this.scene.mapWidth - 150);\r\n            const y = Phaser.Math.Between(150, this.scene.mapHeight - 150);\r\n            const radius = Phaser.Math.Between(100, 180);\r\n            this.scene.fertileZones.push(new Phaser.Geom.Circle(x, y, radius));\r\n            const iso = toIso(x, y);\r\n            const graphics = this.scene.add.graphics();\r\n            graphics.setDepth(-9500);\r\n            graphics.fillStyle(0x3e2723, 0.4);\r\n            graphics.fillEllipse(iso.x, iso.y, radius * 2, radius);\r\n        }\r\n    }\r\n\r\n    generateForestsAndAnimals() {\r\n        const forestCount = Math.floor((this.scene.mapWidth * this.scene.mapHeight) / (800 * 800));\r\n        for (let i = 0; i < forestCount; i++) {\r\n            const fx = Phaser.Math.Between(100, this.scene.mapWidth - 100);\r\n            const fy = Phaser.Math.Between(100, this.scene.mapHeight - 100);\r\n            const fRadius = Phaser.Math.Between(200, 450);\r\n            const treeCount = Math.floor(fRadius * 0.4);\r\n            for (let j = 0; j < treeCount; j++) {\r\n                const angle = Math.random() * Math.PI * 2;\r\n                const dist = Math.sqrt(Math.random()) * fRadius;\r\n                const tx = fx + Math.cos(angle) * dist;\r\n                const ty = fy + Math.sin(angle) * dist;\r\n                if (Phaser.Math.Distance.Between(tx, ty, this.scene.mapWidth / 2, this.scene.mapHeight / 2) > 250) {\r\n                    if (tx > 50 && tx < this.scene.mapWidth - 50 && ty > 50 && ty < this.scene.mapHeight - 50) {\r\n                        this.scene.entityFactory.spawnTree(tx, ty);\r\n                    }\r\n                }\r\n            }\r\n            const animalCount = Phaser.Math.Between(2, 5);\r\n            for (let k = 0; k < animalCount; k++) {\r\n                const angle = Math.random() * Math.PI * 2;\r\n                const ax = fx + Math.cos(angle) * (fRadius * 0.8);\r\n                const ay = fy + Math.sin(angle) * (fRadius * 0.8);\r\n                if (Phaser.Math.Distance.Between(ax, ay, this.scene.mapWidth / 2, this.scene.mapHeight / 2) > 300) {\r\n                    if (ax > 50 && ax < this.scene.mapWidth - 50 && ay > 50 && ay < this.scene.mapHeight - 50) {\r\n                        this.scene.entityFactory.spawnUnit(UnitType.ANIMAL, ax, ay, -1);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\LGSM228\\CivStrategy\\game\\systems\\MinimapSystem.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":128,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":128,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4900,4903],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4900,4903],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":171,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":171,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6383,6386],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6383,6386],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":191,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":191,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7223,7226],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7223,7226],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":229,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":229,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8499,8502],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8499,8502],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":245,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":245,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9204,9207],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9204,9207],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\r\nimport Phaser from 'phaser';\r\nimport { MainScene } from '../MainScene';\r\nimport { MapMode, UnitType } from '../../types';\r\nimport { UNIT_VISION } from '../../constants';\r\nimport { toCartesian } from '../utils/iso';\r\n\r\nexport class MinimapSystem {\r\n    private scene: MainScene;\r\n    private renderTexture: Phaser.GameObjects.RenderTexture;\r\n    private staticTexture: Phaser.GameObjects.RenderTexture;\r\n\r\n    private mapSize = 192; // Match React UI w-48\r\n    private padding = 24;  // Match React UI bottom-6 left-6\r\n\r\n    private unitDot: Phaser.GameObjects.Graphics;\r\n    private buildingRect: Phaser.GameObjects.Graphics;\r\n    private viewportGraphics: Phaser.GameObjects.Graphics;\r\n\r\n    private maskGraphics: Phaser.GameObjects.Graphics;\r\n    private borderGraphics: Phaser.GameObjects.Graphics;\r\n\r\n    private updateInterval = 15;\r\n    private frameCount = 0;\r\n    private dirtyStatic = true; // Flag to redraw static layer\r\n\r\n    private fogRT: Phaser.GameObjects.RenderTexture;\r\n    private fogBrush: Phaser.GameObjects.Graphics;\r\n\r\n    constructor(scene: MainScene) {\r\n        this.scene = scene;\r\n\r\n        // 1. Create Render Textures\r\n        this.renderTexture = this.scene.add.renderTexture(0, 0, this.mapSize, this.mapSize);\r\n        this.renderTexture.setOrigin(0, 0).setScrollFactor(0).setDepth(20000);\r\n\r\n        // Static layer for trees, background, resources (cached)\r\n        this.staticTexture = this.scene.make.renderTexture({ width: this.mapSize, height: this.mapSize }, false);\r\n        this.staticTexture.setOrigin(0, 0);\r\n\r\n        // Fog Layer\r\n        this.fogRT = this.scene.add.renderTexture(0, 0, this.mapSize, this.mapSize);\r\n        this.fogRT.setOrigin(0, 0).setScrollFactor(0).setDepth(20002); // Above map, below border\r\n        this.fogRT.setAlpha(1.0); // Full black\r\n\r\n        // 2. Create Reusable 'Brushes'\r\n        this.unitDot = this.scene.make.graphics({});\r\n        this.unitDot.setVisible(false);\r\n\r\n        this.buildingRect = this.scene.make.graphics({});\r\n        this.buildingRect.setVisible(false);\r\n\r\n        this.viewportGraphics = this.scene.make.graphics({});\r\n        this.viewportGraphics.setVisible(false);\r\n\r\n        this.fogBrush = this.scene.make.graphics({});\r\n        this.fogBrush.setVisible(false);\r\n\r\n        // 3. Circular Mask\r\n        this.maskGraphics = this.scene.make.graphics({});\r\n        this.maskGraphics.fillStyle(0xffffff);\r\n        this.maskGraphics.fillCircle(this.mapSize / 2, this.mapSize / 2, this.mapSize / 2);\r\n        this.maskGraphics.setScrollFactor(0).setVisible(false);\r\n\r\n        const mask = this.maskGraphics.createGeometryMask();\r\n        this.renderTexture.setMask(mask);\r\n        this.fogRT.setMask(mask);\r\n\r\n        // 4. Border\r\n        this.borderGraphics = this.scene.add.graphics();\r\n        this.borderGraphics.setScrollFactor(0).setDepth(20003); // Top most\r\n\r\n        // Initial Layout\r\n        this.updateLayout();\r\n    }\r\n\r\n    public refreshStaticLayer() {\r\n        this.dirtyStatic = true;\r\n    }\r\n\r\n    private updateLayout() {\r\n        const cam = this.scene.cameras.main;\r\n        const zoom = cam.zoom;\r\n        const invZoom = 1 / zoom;\r\n        const w = this.scene.scale.width;\r\n        const h = this.scene.scale.height;\r\n\r\n        const targetX = this.padding;\r\n        const targetY = h - this.mapSize - this.padding;\r\n\r\n        const x = (targetX - w * 0.5) * invZoom + w * 0.5;\r\n        const y = (targetY - h * 0.5) * invZoom + h * 0.5;\r\n\r\n        this.renderTexture.setPosition(x, y).setScale(invZoom);\r\n        this.fogRT.setPosition(x, y).setScale(invZoom);\r\n        this.maskGraphics.setPosition(x, y).setScale(invZoom);\r\n\r\n        this.borderGraphics.setPosition(x, y).setScale(invZoom);\r\n        this.borderGraphics.clear();\r\n        this.borderGraphics.lineStyle(3 * zoom, 0x44403c, 1.0);\r\n        this.borderGraphics.strokeCircle(this.mapSize / 2, this.mapSize / 2, this.mapSize / 2);\r\n    }\r\n\r\n    private drawStaticLayer(scalar: number) {\r\n        this.staticTexture.clear();\r\n        this.staticTexture.fill(0x064e3b); // Background\r\n\r\n        // Draw Fertile Zones\r\n        this.buildingRect.clear();\r\n        this.buildingRect.fillStyle(0x451a03, 0.5);\r\n        for (const zone of this.scene.fertileZones) {\r\n            const pos = this.worldToMini(zone.x, zone.y, scalar);\r\n            if (this.isInBounds(pos)) {\r\n                const r = zone.radius * scalar;\r\n                this.buildingRect.fillCircle(0, 0, r);\r\n                this.staticTexture.draw(this.buildingRect, pos.x, pos.y);\r\n            }\r\n        }\r\n\r\n        // Draw Trees (The heavy part)\r\n        this.unitDot.clear();\r\n        this.unitDot.fillStyle(0x022c22, 0.8);\r\n\r\n        // Batch all tree drawings into the Graphics object first\r\n        const trees = this.scene.trees.getChildren();\r\n        let treesDrawn = 0;\r\n        for (const t of trees) {\r\n            const tree = t as any;\r\n            if (tree.getData('isChopped')) continue; // Don't draw chopped trees\r\n\r\n            const pos = this.worldToMini(tree.x, tree.y, scalar);\r\n            if (this.isInBounds(pos)) {\r\n                // Direct fill circle on graphics, do NOT draw to texture yet\r\n                this.unitDot.fillCircle(pos.x, pos.y, 1.5);\r\n                treesDrawn++;\r\n            }\r\n        }\r\n\r\n        // Single draw call to RenderTexture\r\n        if (treesDrawn > 0) {\r\n            this.staticTexture.draw(this.unitDot, 0, 0);\r\n        }\r\n    }\r\n\r\n    private isInBounds(pos: { x: number, y: number }) {\r\n        return pos.x >= -10 && pos.x <= this.mapSize + 10 && pos.y >= -10 && pos.y <= this.mapSize + 10;\r\n    }\r\n\r\n    public update() {\r\n        this.updateLayout();\r\n\r\n        this.frameCount++;\r\n        if (this.frameCount < this.updateInterval) return;\r\n        this.frameCount = 0;\r\n\r\n        const scalar = this.getMapScalar();\r\n\r\n        // 1. Update Static Layer if needed\r\n        if (this.dirtyStatic) {\r\n            this.drawStaticLayer(scalar);\r\n            this.dirtyStatic = false;\r\n        }\r\n\r\n        // 2. Clear Main Texture and Draw Static Layer\r\n        this.renderTexture.clear();\r\n        this.renderTexture.draw(this.staticTexture, 0, 0);\r\n\r\n        // 3. Draw Buildings (Dynamic ownership/health, so draw every time)\r\n        const buildings = this.scene.buildings.getChildren();\r\n        for (const b of buildings) {\r\n            const build = b as any;\r\n            const pos = this.worldToMini(build.x, build.y, scalar);\r\n\r\n            if (this.isInBounds(pos)) {\r\n                const def = build.getData('def');\r\n                const owner = build.getData('owner');\r\n                const color = owner === 0 ? 0x3b82f6 : (owner === 1 ? 0xef4444 : 0xaaaaaa);\r\n                const size = Math.max(3, def.width * scalar);\r\n\r\n                this.buildingRect.clear();\r\n                this.buildingRect.fillStyle(color, 1);\r\n                this.buildingRect.fillRect(-size / 2, -size / 2, size, size);\r\n                this.renderTexture.draw(this.buildingRect, pos.x, pos.y);\r\n            }\r\n        }\r\n\r\n        // 4. Draw Units\r\n        const units = this.scene.units.getChildren();\r\n        this.unitDot.clear();\r\n        for (const u of units) {\r\n            const unit = u as any;\r\n            const pos = this.worldToMini(unit.x, unit.y, scalar);\r\n\r\n            if (this.isInBounds(pos)) {\r\n                const type = unit.unitType;\r\n                const owner = unit.getData('owner');\r\n                let color = owner === 0 ? 0x60a5fa : (owner === 1 ? 0xf87171 : 0xffffff);\r\n                let radius = 2.5;\r\n                if (type === UnitType.ANIMAL) { color = 0x9ca3af; radius = 1; }\r\n\r\n                this.unitDot.fillStyle(color, 1);\r\n                this.unitDot.fillCircle(0, 0, radius);\r\n                this.renderTexture.draw(this.unitDot, pos.x, pos.y);\r\n            }\r\n        }\r\n\r\n        // 5. Update Fog of War\r\n        this.updateFog(scalar);\r\n\r\n        // 6. Viewport\r\n        this.drawViewport(scalar);\r\n    }\r\n\r\n    private updateFog(scalar: number) {\r\n        if (!this.scene.isFowEnabled) {\r\n            this.fogRT.setVisible(false);\r\n            return;\r\n        }\r\n        this.fogRT.setVisible(true);\r\n        this.fogRT.clear();\r\n        this.fogRT.fill(0x000000, 1.0);\r\n\r\n        // Use custom blend mode to Erase\r\n        this.fogBrush.clear();\r\n        this.fogBrush.fillStyle(0xffffff, 1);\r\n\r\n        const units = this.scene.units.getChildren();\r\n        for (const u of units) {\r\n            const unit = u as any;\r\n            // Only friendly units reveal fog\r\n            if (unit.getData('owner') !== 0) continue;\r\n            // Animals don't reveal fog (usually)\r\n            if (unit.unitType === UnitType.ANIMAL) continue;\r\n\r\n            const pos = this.worldToMini(unit.x, unit.y, scalar);\r\n            if (this.isInBounds(pos)) {\r\n                // Approximate Minimap Vision radius\r\n                const range = (UNIT_VISION[unit.unitType as UnitType] || 250) * scalar * 1.5;\r\n                this.fogBrush.fillCircle(pos.x, pos.y, range);\r\n            }\r\n        }\r\n\r\n        const buildings = this.scene.buildings.getChildren();\r\n        for (const b of buildings) {\r\n            const build = b as any;\r\n            if (build.getData('owner') !== 0) continue;\r\n\r\n            const pos = this.worldToMini(build.x, build.y, scalar);\r\n            if (this.isInBounds(pos)) {\r\n                const def = build.getData('def');\r\n                // Use territory or vision radius\r\n                const range = (def.territoryRadius || def.visionRadius || 200) * scalar;\r\n                this.fogBrush.fillCircle(pos.x, pos.y, range);\r\n            }\r\n        }\r\n\r\n        // Erase using the brush\r\n        this.fogRT.erase(this.fogBrush);\r\n    }\r\n\r\n    private drawViewport(scalar: number) {\r\n        const cam = this.scene.cameras.main;\r\n        const tl = cam.getWorldPoint(0, 0);\r\n        const tr = cam.getWorldPoint(cam.width, 0);\r\n        const bl = cam.getWorldPoint(0, cam.height);\r\n        const br = cam.getWorldPoint(cam.width, cam.height);\r\n\r\n        const cTl = toCartesian(tl.x, tl.y);\r\n        const cTr = toCartesian(tr.x, tr.y);\r\n        const cBl = toCartesian(bl.x, bl.y);\r\n        const cBr = toCartesian(br.x, br.y);\r\n\r\n        const mTl = this.worldToMini(cTl.x, cTl.y, scalar);\r\n        const mTr = this.worldToMini(cTr.x, cTr.y, scalar);\r\n        const mBl = this.worldToMini(cBl.x, cBl.y, scalar);\r\n        const mBr = this.worldToMini(cBr.x, cBr.y, scalar);\r\n\r\n        this.viewportGraphics.clear();\r\n        this.viewportGraphics.lineStyle(2, 0xfacc15, 1.0);\r\n        this.viewportGraphics.beginPath();\r\n        this.viewportGraphics.moveTo(mTl.x, mTl.y);\r\n        this.viewportGraphics.lineTo(mTr.x, mTr.y);\r\n        this.viewportGraphics.lineTo(mBr.x, mBr.y);\r\n        this.viewportGraphics.lineTo(mBl.x, mBl.y);\r\n        this.viewportGraphics.closePath();\r\n        this.viewportGraphics.strokePath();\r\n\r\n        this.renderTexture.draw(this.viewportGraphics, 0, 0);\r\n    }\r\n\r\n    public getWorldFromMinimap(miniX: number, miniY: number): { x: number, y: number } {\r\n        const scalar = this.getMapScalar();\r\n        if (this.scene.mapMode === MapMode.INFINITE) {\r\n            const cam = this.scene.cameras.main;\r\n            const center = toCartesian(cam.worldView.centerX, cam.worldView.centerY);\r\n            const dx = miniX - this.mapSize / 2;\r\n            const dy = miniY - this.mapSize / 2;\r\n            return { x: center.x + dx / scalar, y: center.y + dy / scalar };\r\n        } else {\r\n            return { x: miniX / scalar, y: miniY / scalar };\r\n        }\r\n    }\r\n\r\n    private getMapScalar(): number {\r\n        const worldSize = this.scene.mapMode === MapMode.FIXED ? this.scene.mapWidth : 4096;\r\n        return this.mapSize / worldSize;\r\n    }\r\n\r\n    private worldToMini(x: number, y: number, scalar: number) {\r\n        if (this.scene.mapMode === MapMode.INFINITE) {\r\n            const cam = this.scene.cameras.main;\r\n            const center = toCartesian(cam.worldView.centerX, cam.worldView.centerY);\r\n            const dx = x - center.x;\r\n            const dy = y - center.y;\r\n            return { x: dx * scalar + this.mapSize / 2, y: dy * scalar + this.mapSize / 2 };\r\n        } else {\r\n            return { x: x * scalar, y: y * scalar };\r\n        }\r\n    }\r\n\r\n    public destroy() {\r\n        if (this.fogRT) this.fogRT.destroy();\r\n        if (this.fogBrush) this.fogBrush.destroy();\r\n        if (this.renderTexture) this.renderTexture.destroy();\r\n        if (this.staticTexture) this.staticTexture.destroy();\r\n        if (this.borderGraphics) this.borderGraphics.destroy();\r\n        if (this.maskGraphics) this.maskGraphics.destroy();\r\n        if (this.unitDot) this.unitDot.destroy();\r\n        if (this.buildingRect) this.buildingRect.destroy();\r\n        if (this.viewportGraphics) this.viewportGraphics.destroy();\r\n    }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\LGSM228\\CivStrategy\\game\\systems\\Pathfinder.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\LGSM228\\CivStrategy\\game\\systems\\SquadSystem.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'UnitStats' is defined but never used. Allowed unused vars must match /^_/u.","line":3,"column":20,"nodeType":null,"messageId":"unusedVar","endLine":3,"endColumn":29},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'FACTION_COLORS' is defined but never used. Allowed unused vars must match /^_/u.","line":4,"column":22,"nodeType":null,"messageId":"unusedVar","endLine":4,"endColumn":36},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'owner' is defined but never used. Allowed unused args must match /^_/u.","line":21,"column":77,"nodeType":null,"messageId":"unusedVar","endLine":21,"endColumn":82},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":50,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":50,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1752,1755],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1752,1755],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":72,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":72,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2592,2595],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2592,2595],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":73,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":73,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2639,2642],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2639,2642],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'dt' is defined but never used. Allowed unused args must match /^_/u.","line":81,"column":19,"nodeType":null,"messageId":"unusedVar","endLine":81,"endColumn":21},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":85,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":85,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3009,3012],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3009,3012],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":8,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import Phaser from 'phaser';\r\nimport { MainScene } from '../MainScene';\r\nimport { UnitType, UnitStats } from '../../types';\r\nimport { UNIT_STATS, FACTION_COLORS } from '../../constants';\r\nimport { toIso } from '../utils/iso';\r\n\r\ninterface SoldierState {\r\n    x: number;\r\n    y: number;\r\n    z: number;\r\n    offset: { x: number, y: number };\r\n}\r\n\r\nexport class SquadSystem {\r\n    private scene: MainScene;\r\n\r\n    constructor(scene: MainScene) {\r\n        this.scene = scene;\r\n    }\r\n\r\n    public createSquad(unit: Phaser.GameObjects.GameObject, type: UnitType, owner: number) {\r\n        const stats = UNIT_STATS[type];\r\n        if (!stats || stats.squadSize <= 1) return;\r\n\r\n        const container = this.scene.add.container(0, 0);\r\n        const gfx = this.scene.add.graphics();\r\n        container.add(gfx);\r\n\r\n        // Create unit indicator label (initially hidden)\r\n        const unitName = type === UnitType.LEGION ? 'LEGION' :\r\n            type === UnitType.SOLDIER ? 'SOLDIERS' :\r\n                type === UnitType.CAVALRY ? 'CAVALRY' : 'UNIT';\r\n        const indicatorLabel = this.scene.add.text(0, -26, unitName, {\r\n            fontFamily: 'Arial',\r\n            fontSize: '10px',\r\n            color: '#ffffff',\r\n            stroke: '#000000',\r\n            strokeThickness: 2\r\n        }).setOrigin(0.5).setVisible(false);\r\n        container.add(indicatorLabel);\r\n        unit.setData('indicatorLabel', indicatorLabel);\r\n\r\n        unit.setData('squadContainer', container);\r\n        unit.setData('squadCurrentCount', stats.squadSize);\r\n        unit.setData('squadMaxCount', stats.squadSize);\r\n        unit.setData('formationAngle', 0);\r\n\r\n        this.initializeSoldiers(unit, stats.squadSize, type);\r\n\r\n        const commanderVisual = (unit as any).visual as Phaser.GameObjects.Container;\r\n        if (commanderVisual) {\r\n            commanderVisual.setVisible(false);\r\n            commanderVisual.removeAll(true);\r\n        }\r\n\r\n        this.scene.add.existing(container);\r\n    }\r\n\r\n    private initializeSoldiers(unit: Phaser.GameObjects.GameObject, count: number, type: UnitType) {\r\n        const stats = UNIT_STATS[type];\r\n        const soldiers: SoldierState[] = [];\r\n        const spacing = stats.squadSpacing || 10;\r\n        const cols = Math.ceil(Math.sqrt(count));\r\n\r\n        for (let i = 0; i < count; i++) {\r\n            const col = i % cols;\r\n            const row = Math.floor(i / cols);\r\n            const offsetX = (col - cols / 2) * spacing;\r\n            const offsetY = (row - (count / cols) / 2) * spacing;\r\n\r\n            soldiers.push({\r\n                x: (unit as any).x + offsetX,\r\n                y: (unit as any).y + offsetY,\r\n                z: 0,\r\n                offset: { x: offsetX, y: offsetY }\r\n            });\r\n        }\r\n        unit.setData('soldierStates', soldiers);\r\n    }\r\n\r\n    public update(dt: number) {\r\n        const units = this.scene.units.getChildren();\r\n\r\n        units.forEach((uObj: Phaser.GameObjects.GameObject) => {\r\n            const unit = uObj as any;\r\n            const container = unit.getData('squadContainer') as Phaser.GameObjects.Container;\r\n            if (!container) return;\r\n\r\n            // Optimization: Skip processing if the squad container is culled\r\n            if (!container.visible) return;\r\n\r\n            const body = unit.body as Phaser.Physics.Arcade.Body;\r\n            const stats = UNIT_STATS[unit.unitType as UnitType];\r\n\r\n            let angle = unit.getData('formationAngle');\r\n            const speed = body.velocity.length();\r\n            const isMoving = speed > 10;\r\n\r\n            if (isMoving) {\r\n                const targetAngle = body.velocity.angle();\r\n                angle = Phaser.Math.Angle.RotateTo(angle, targetAngle, 0.1);\r\n                unit.setData('formationAngle', angle);\r\n            }\r\n\r\n            const commanderIso = toIso(unit.x, unit.y);\r\n            container.setPosition(commanderIso.x, commanderIso.y);\r\n            container.setDepth(commanderIso.y);\r\n\r\n            const hp = unit.getData('hp');\r\n            const maxHp = unit.getData('maxHp');\r\n            const targetCount = Math.ceil((hp / maxHp) * stats.squadSize);\r\n            const soldiers = unit.getData('soldierStates') as SoldierState[];\r\n\r\n            if (soldiers.length !== targetCount) {\r\n                if (soldiers.length > targetCount) {\r\n                    soldiers.splice(targetCount);\r\n                } else {\r\n                    while (soldiers.length < targetCount) {\r\n                        soldiers.push({\r\n                            x: unit.x,\r\n                            y: unit.y,\r\n                            z: 0,\r\n                            offset: { x: (Math.random() - 0.5) * 10, y: (Math.random() - 0.5) * 10 }\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n\r\n            const gfx = container.getAt(0) as Phaser.GameObjects.Graphics;\r\n            gfx.clear();\r\n\r\n            const owner = unit.getData('owner');\r\n            const color = this.scene.getFactionColor(owner);\r\n\r\n            const cos = Math.cos(angle);\r\n            const sin = Math.sin(angle);\r\n\r\n            if (unit.isSelected) {\r\n                gfx.lineStyle(2, 0xffffff, 0.8);\r\n                const radius = Math.sqrt(stats.squadSize) * (stats.squadSpacing || 10) * 0.7;\r\n                gfx.strokeEllipse(0, 0, radius * 2.5, radius * 1.5);\r\n            }\r\n\r\n            // Unit Indicator Icon (Global Toggle)\r\n            // Unit Indicator Icon (Global Toggle)\r\n            if (this.scene.showUnitIndicators && owner === 0) {\r\n                const indicatorY = -60; // Position above the squad\r\n                const circleRadius = 22;\r\n\r\n                // Background circle with border\r\n                gfx.fillStyle(0x1a1a2e, 0.95);\r\n                gfx.fillCircle(0, indicatorY, circleRadius);\r\n                gfx.lineStyle(2, 0xffffff, 0.9);\r\n                gfx.strokeCircle(0, indicatorY, circleRadius);\r\n\r\n                // Draw unit icon silhouette inside\r\n                gfx.fillStyle(0xffffff, 0.9);\r\n                if (unit.unitType === UnitType.SOLDIER || unit.unitType === UnitType.LEGION) {\r\n                    // Soldier icon: body + head + spear\r\n                    gfx.fillRect(-3, indicatorY - 8, 6, 12); // body\r\n                    gfx.fillCircle(0, indicatorY - 12, 4); // head\r\n                    gfx.fillRect(5, indicatorY - 14, 2, 18); // spear\r\n                    gfx.fillStyle(0x888888, 0.9);\r\n                    gfx.fillTriangle(6, indicatorY - 14, 4, indicatorY - 10, 8, indicatorY - 10); // spear tip\r\n                } else if (unit.unitType === UnitType.CAVALRY) {\r\n                    // Cavalry icon: horse shape + rider\r\n                    gfx.fillEllipse(0, indicatorY + 2, 16, 8); // horse body\r\n                    gfx.fillCircle(-6, indicatorY - 2, 3); // horse head\r\n                    gfx.fillRect(-2, indicatorY - 8, 4, 6); // rider body\r\n                    gfx.fillCircle(0, indicatorY - 12, 3); // rider head\r\n                } else if (unit.unitType === UnitType.ARCHER) {\r\n                    // Archer icon: Bow path\r\n                    gfx.lineStyle(2, 0xffffff, 1);\r\n                    gfx.beginPath();\r\n                    gfx.arc(0, indicatorY, 8, Phaser.Math.DegToRad(-45), Phaser.Math.DegToRad(45), false); // Bow curve\r\n                    gfx.strokePath();\r\n                    // Arrow\r\n                    gfx.lineStyle(1, 0xffffff, 1);\r\n                    gfx.beginPath();\r\n                    gfx.moveTo(-8, indicatorY);\r\n                    gfx.lineTo(8, indicatorY);\r\n                    gfx.strokePath();\r\n                }\r\n\r\n                // Unit type name below the indicator\r\n                const unitName = unit.unitType === UnitType.LEGION ? 'LEGION' :\r\n                    unit.unitType === UnitType.SOLDIER ? 'SOLDIERS' :\r\n                        unit.unitType === UnitType.ARCHER ? 'ARCHERS' :\r\n                            unit.unitType === UnitType.CAVALRY ? 'CAVALRY' : 'UNIT';\r\n\r\n                // Draw text background\r\n                const textY = indicatorY + circleRadius + 10;\r\n                gfx.fillStyle(0x000000, 0.7);\r\n                gfx.fillRoundedRect(-35, textY - 8, 70, 14, 4);\r\n\r\n                // Show and position the indicator label\r\n                const indicatorLabel = unit.getData('indicatorLabel') as Phaser.GameObjects.Text;\r\n                if (indicatorLabel) {\r\n                    indicatorLabel.setText(unitName); // Ensure name is correct\r\n                    indicatorLabel.setY(textY);\r\n                    indicatorLabel.setVisible(true);\r\n                }\r\n            } else {\r\n                // Hide indicator label when not showing\r\n                const indicatorLabel = unit.getData('indicatorLabel') as Phaser.GameObjects.Text;\r\n                if (indicatorLabel) {\r\n                    indicatorLabel.setVisible(false);\r\n                }\r\n            }\r\n\r\n            soldiers.forEach((soldier, index) => {\r\n                const dx = soldier.offset.x * cos - soldier.offset.y * sin;\r\n                const dy = soldier.offset.x * sin + soldier.offset.y * cos;\r\n                const targetX = unit.x + dx;\r\n                const targetY = unit.y + dy;\r\n\r\n                const lerpSpeed = isMoving ? 0.15 : 0.1;\r\n                soldier.x = Phaser.Math.Linear(soldier.x, targetX, lerpSpeed);\r\n                soldier.y = Phaser.Math.Linear(soldier.y, targetY, lerpSpeed);\r\n\r\n                if (isMoving) {\r\n                    soldier.z = Math.abs(Math.sin((this.scene.time.now / 150) + index)) * 3;\r\n                } else {\r\n                    soldier.z = Phaser.Math.Linear(soldier.z, 0, 0.2);\r\n                }\r\n\r\n                const isoSoldier = toIso(soldier.x, soldier.y);\r\n                const drawX = isoSoldier.x - commanderIso.x;\r\n                const drawY = isoSoldier.y - commanderIso.y - soldier.z;\r\n\r\n                if (unit.unitType === UnitType.LEGION || unit.unitType === UnitType.SOLDIER || unit.unitType === UnitType.ARCHER) {\r\n                    gfx.fillStyle(0x000000, 0.3);\r\n                    gfx.fillEllipse(drawX, drawY + soldier.z, 6, 3);\r\n                    gfx.fillStyle(color, 1);\r\n                    gfx.fillRect(drawX - 2, drawY - 4, 4, 6);\r\n                    gfx.fillStyle(0xffffff, 0.8);\r\n                    gfx.fillRect(drawX - 1, drawY - 6, 2, 2);\r\n                } else if (unit.unitType === UnitType.CAVALRY) {\r\n                    gfx.fillStyle(0x000000, 0.3);\r\n                    gfx.fillEllipse(drawX, drawY + soldier.z, 10, 5);\r\n                    gfx.fillStyle(color, 1);\r\n                    gfx.fillEllipse(drawX, drawY, 14, 8);\r\n                    gfx.fillStyle(0xffffff, 1);\r\n                    gfx.fillCircle(drawX, drawY - 5, 2.5);\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    public destroySquad(unit: Phaser.GameObjects.GameObject) {\r\n        const container = unit.getData('squadContainer') as Phaser.GameObjects.Container;\r\n        if (container) {\r\n            container.destroy();\r\n        }\r\n    }\r\n}","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\LGSM228\\CivStrategy\\game\\systems\\UnitSystem.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'UnitStats' is defined but never used. Allowed unused vars must match /^_/u.","line":4,"column":31,"nodeType":null,"messageId":"unusedVar","endLine":4,"endColumn":40},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'TILE_SIZE' is defined but never used. Allowed unused vars must match /^_/u.","line":5,"column":33,"nodeType":null,"messageId":"unusedVar","endLine":5,"endColumn":42},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":35,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":35,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1223,1226],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1223,1226],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":70,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":70,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2676,2679],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2676,2679],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error.","line":88,"column":17,"nodeType":"MemberExpression","messageId":"limited","endLine":88,"endColumn":28,"suggestions":[{"fix":{"range":[3619,3673],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error.","line":94,"column":17,"nodeType":"MemberExpression","messageId":"limited","endLine":94,"endColumn":28,"suggestions":[{"fix":{"range":[3909,3961],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":99,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":99,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4066,4069],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4066,4069],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error.","line":100,"column":13,"nodeType":"MemberExpression","messageId":"limited","endLine":100,"endColumn":24,"suggestions":[{"fix":{"range":[4094,4132],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":102,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":102,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4207,4210],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4207,4210],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error.","line":109,"column":13,"nodeType":"MemberExpression","messageId":"limited","endLine":109,"endColumn":24,"suggestions":[{"fix":{"range":[4385,4430],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'delta' is defined but never used. Allowed unused args must match /^_/u.","line":113,"column":43,"nodeType":null,"messageId":"unusedVar","endLine":113,"endColumn":48},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":115,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":115,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4636,4639],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4636,4639],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":180,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":180,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7821,7824],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7821,7824],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":181,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":181,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7858,7861],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7858,7861],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":195,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":195,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8471,8474],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8471,8474],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error.","line":220,"column":17,"nodeType":"MemberExpression","messageId":"limited","endLine":220,"endColumn":28,"suggestions":[{"fix":{"range":[9301,9375],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":232,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":232,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9776,9779],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9776,9779],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":232,"column":46,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":232,"endColumn":49,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9789,9792],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9789,9792],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error.","line":234,"column":9,"nodeType":"MemberExpression","messageId":"limited","endLine":234,"endColumn":20,"suggestions":[{"fix":{"range":[9856,9943],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":298,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":298,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12538,12541],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12538,12541],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":298,"column":47,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":298,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12551,12554],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12551,12554],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":363,"column":52,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":363,"endColumn":55,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15125,15128],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15125,15128],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":392,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":392,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16387,16390],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16387,16390],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":17,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\r\nimport Phaser from 'phaser';\r\nimport { MainScene } from '../MainScene';\r\nimport { UnitType, UnitState, UnitStats } from '../../types';\r\nimport { MAP_WIDTH, MAP_HEIGHT, TILE_SIZE, UNIT_SPEED, UNIT_STATS } from '../../constants';\r\nimport { toIso } from '../utils/iso';\r\n\r\nexport class UnitSystem {\r\n    private scene: MainScene;\r\n    private pathGraphics: Phaser.GameObjects.Graphics;\r\n    private debugGraphics: Phaser.GameObjects.Graphics;\r\n\r\n    constructor(scene: MainScene) {\r\n        this.scene = scene;\r\n        this.pathGraphics = this.scene.add.graphics().setDepth(-4000);\r\n        this.debugGraphics = this.scene.add.graphics().setDepth(100000);\r\n    }\r\n\r\n    public update(time: number, delta: number) {\r\n        this.updateUnitLogic(time, delta);\r\n        this.drawUnitPaths(time);\r\n\r\n        if (this.scene.debugMode) {\r\n            this.drawDebugLines();\r\n        } else {\r\n            this.debugGraphics.clear();\r\n        }\r\n    }\r\n\r\n    public commandMove(units: Phaser.GameObjects.GameObject[], target: Phaser.Math.Vector2) {\r\n        const spacing = 15;\r\n        const formationCols = Math.ceil(Math.sqrt(units.length));\r\n\r\n        units.forEach((unitObj, index) => {\r\n            const unit = unitObj as any;\r\n            const col = index % formationCols;\r\n            const row = Math.floor(index / formationCols);\r\n            const offsetX = (col - formationCols / 2) * spacing;\r\n            const offsetY = (row - Math.ceil(units.length / formationCols) / 2) * spacing;\r\n            const unitTarget = new Phaser.Math.Vector2(target.x + offsetX, target.y + offsetY);\r\n\r\n            const path = this.scene.pathfinder.findPath(new Phaser.Math.Vector2(unit.x, unit.y), unitTarget);\r\n            if (path) {\r\n                unit.path = path;\r\n                unit.pathStep = 0;\r\n                unit.pathCreatedAt = this.scene.gameTime;\r\n                unit.state = UnitState.IDLE;\r\n                unit.target = null; // Clear combat target\r\n                unit.body.reset(unit.x, unit.y);\r\n            }\r\n        });\r\n\r\n        // Visual feedback\r\n        const iso = toIso(target.x, target.y);\r\n        const circle = this.scene.add.circle(iso.x, iso.y, 5, 0xffffff);\r\n        circle.setScale(1, 0.5);\r\n        circle.setDepth(iso.y);\r\n        this.scene.tweens.add({\r\n            targets: circle,\r\n            scaleX: 0,\r\n            scaleY: 0,\r\n            alpha: 0,\r\n            duration: 500,\r\n            onComplete: () => circle.destroy()\r\n        });\r\n    }\r\n\r\n    public commandAttack(units: Phaser.GameObjects.GameObject[], target: Phaser.GameObjects.GameObject) {\r\n        units.forEach((unitObj) => {\r\n            const unit = unitObj as any;\r\n\r\n            // --- SECURITY BLOCK ---\r\n            // If peaceful mode is active and this is an ENEMY unit, reject the attack command entirely.\r\n            if (this.scene.peacefulMode && unit.getData('owner') !== 0) {\r\n                // Flash a debug indicator if in debug mode\r\n                if (this.scene.debugMode) {\r\n                    const iso = toIso(unit.x, unit.y);\r\n                    const x = this.scene.add.text(iso.x, iso.y, \"X\", { color: '#ff0000', fontSize: '20px' });\r\n                    x.setOrigin(0.5);\r\n                    this.scene.tweens.add({ targets: x, y: iso.y - 20, alpha: 0, duration: 500, onComplete: () => x.destroy() });\r\n                }\r\n                return;\r\n            }\r\n            // ----------------------\r\n\r\n            // Only combat units attack\r\n            if ([UnitType.SOLDIER, UnitType.CAVALRY, UnitType.LEGION, UnitType.ARCHER].includes(unit.unitType)) {\r\n                console.log(`Unit ${unit.unitType} engaging target.`);\r\n                unit.target = target;\r\n                unit.state = UnitState.CHASING;\r\n                unit.path = null; // Clear old move path\r\n                unit.body.reset(unit.x, unit.y);\r\n            } else {\r\n                console.log(`Unit ${unit.unitType} CANNOT attack.`);\r\n            }\r\n        });\r\n\r\n        // Visual Feedback (Red Flash on target)\r\n        if ((target as any).visual) {\r\n            console.log(\"Flashing Target visual\");\r\n            this.scene.tweens.add({\r\n                targets: (target as any).visual,\r\n                alpha: 0.5,\r\n                yoyo: true,\r\n                duration: 100,\r\n                repeat: 2\r\n            });\r\n        } else {\r\n            console.log(\"Target has no visual to flash\");\r\n        }\r\n    }\r\n\r\n    private updateUnitLogic(time: number, delta: number) {\r\n        this.scene.units.getChildren().forEach((item: Phaser.GameObjects.GameObject) => {\r\n            const unit = item as any;\r\n            const body = unit.body as Phaser.Physics.Arcade.Body;\r\n\r\n            if (!body) return;\r\n\r\n            // Failsafe: If peaceful mode is on, force enemy combat units to stop attacking\r\n            if (this.scene.peacefulMode === true && unit.getData('owner') !== 0) {\r\n                if (unit.state === UnitState.CHASING || unit.state === UnitState.ATTACKING) {\r\n                    unit.state = UnitState.IDLE;\r\n                    unit.target = null;\r\n                    body.setVelocity(0, 0);\r\n                }\r\n            }\r\n\r\n            // Combat State Logic\r\n            if (unit.state === UnitState.CHASING || unit.state === UnitState.ATTACKING) {\r\n                this.handleCombatState(unit, time);\r\n            }\r\n            // --- ANIMAL WANDERING AI ---\r\n            else if (unit.unitType === UnitType.ANIMAL) {\r\n                if (body.velocity.length() > 0) {\r\n                    const dest = unit.getData('wanderDest') as Phaser.Math.Vector2;\r\n                    if (dest && Phaser.Math.Distance.Between(unit.x, unit.y, dest.x, dest.y) < 5) {\r\n                        body.setVelocity(0, 0);\r\n                        unit.state = UnitState.IDLE;\r\n                    }\r\n                } else if (Math.random() < 0.005) {\r\n                    const wanderRadius = 100;\r\n                    const angle = Math.random() * Math.PI * 2;\r\n                    const dist = Math.random() * wanderRadius;\r\n                    const tx = Phaser.Math.Clamp(unit.x + Math.cos(angle) * dist, 50, MAP_WIDTH - 50);\r\n                    const ty = Phaser.Math.Clamp(unit.y + Math.sin(angle) * dist, 50, MAP_HEIGHT - 50);\r\n\r\n                    unit.setData('wanderDest', new Phaser.Math.Vector2(tx, ty));\r\n                    this.scene.physics.moveTo(unit, tx, ty, 20);\r\n                    unit.state = UnitState.WANDERING;\r\n                }\r\n            }\r\n            // --- PATH FOLLOWING ---\r\n            else if (unit.path && unit.path.length > 0) {\r\n                if (unit.pathStep >= unit.path.length) {\r\n                    body.setVelocity(0, 0);\r\n                    unit.path = null;\r\n                    if (unit.unitType === UnitType.VILLAGER) {\r\n                        if (unit.state === UnitState.MOVING_TO_WORK) unit.state = UnitState.WORKING;\r\n                        else if (unit.state === UnitState.MOVING_TO_RALLY) unit.state = UnitState.IDLE;\r\n                    }\r\n                    return;\r\n                }\r\n                const nextPoint = unit.path[unit.pathStep];\r\n                const dist = Phaser.Math.Distance.Between(unit.x, unit.y, nextPoint.x, nextPoint.y);\r\n                const speed = UNIT_SPEED[unit.unitType as UnitType] || 100;\r\n\r\n                if (dist < 4) {\r\n                    unit.pathStep++;\r\n                } else {\r\n                    this.scene.physics.moveTo(unit, nextPoint.x, nextPoint.y, speed);\r\n                }\r\n            } else {\r\n                if (body.velocity.length() > 0) body.setVelocity(0, 0);\r\n            }\r\n        });\r\n\r\n        // Separation\r\n        this.scene.physics.overlap(this.scene.units, this.scene.units, (obj1, obj2) => {\r\n            const u1 = obj1 as any;\r\n            const u2 = obj2 as any;\r\n            if (u1 === u2) return;\r\n            const dist = Phaser.Math.Distance.Between(u1.x, u1.y, u2.x, u2.y);\r\n            if (dist < 18) {\r\n                const angle = Phaser.Math.Angle.Between(u2.x, u2.y, u1.x, u1.y);\r\n                const force = (18 - dist) * 1.5;\r\n                u1.body.velocity.x += Math.cos(angle) * force;\r\n                u1.body.velocity.y += Math.sin(angle) * force;\r\n                u2.body.velocity.x -= Math.cos(angle) * force;\r\n                u2.body.velocity.y -= Math.sin(angle) * force;\r\n            }\r\n        });\r\n    }\r\n\r\n    private handleCombatState(unit: any, time: number) {\r\n        const target = unit.target;\r\n\r\n        // Target dead or destroyed\r\n        if (!target || !target.scene) {\r\n            unit.state = UnitState.IDLE;\r\n            unit.target = null;\r\n            unit.body.setVelocity(0, 0);\r\n            return;\r\n        }\r\n\r\n        const dist = Phaser.Math.Distance.Between(unit.x, unit.y, target.x, target.y);\r\n        const range = unit.getData('range') || 40;\r\n        const attackSpeed = unit.getData('attackSpeed') || 1000;\r\n\r\n        // Attack Logic\r\n        if (dist <= range) {\r\n            unit.body.setVelocity(0, 0);\r\n            unit.state = UnitState.ATTACKING;\r\n\r\n            const now = time;\r\n            const last = unit.lastAttackTime || 0;\r\n            const cooldown = attackSpeed;\r\n\r\n            if (now - last > cooldown) {\r\n                console.log(`Attack Ready! Time: ${now}, Last: ${last}, CD: ${cooldown}`);\r\n                unit.lastAttackTime = now;\r\n                this.performAttack(unit, target);\r\n            }\r\n        } else {\r\n            // Chase Logic\r\n            unit.state = UnitState.CHASING;\r\n            const speed = UNIT_SPEED[unit.unitType as UnitType] || 100;\r\n            this.scene.physics.moveTo(unit, target.x, target.y, speed);\r\n        }\r\n    }\r\n\r\n    private performAttack(unit: any, target: any) {\r\n        const dmg = unit.getData('attack') || 10;\r\n        console.log(`PerformAttack: ${unit.unitType} -> Target (HP: ${target.getData('hp')})`);\r\n\r\n        if (unit.unitType === UnitType.ARCHER) {\r\n            // VOLLEY LOGIC\r\n            // Calculate active soldiers based on HP ratio\r\n            const maxHp = unit.getData('maxHp');\r\n            const currentHp = unit.getData('hp');\r\n            const squadSize = UNIT_STATS[UnitType.ARCHER].squadSize;\r\n\r\n            // At least 1 arrow, up to squadSize\r\n            const arrowCount = Math.max(1, Math.ceil((currentHp / maxHp) * squadSize));\r\n            const damagePerArrow = dmg / arrowCount;\r\n\r\n            for (let i = 0; i < arrowCount; i++) {\r\n                // Randomize delay for loose volley feel (0-300ms)\r\n                const delay = Phaser.Math.Between(0, 300);\r\n\r\n                // Add minor random offset to target position for visual variety\r\n                const spread = 15;\r\n                const targetVaried = {\r\n                    x: target.x + Phaser.Math.Between(-spread, spread),\r\n                    y: target.y + Phaser.Math.Between(-spread, spread),\r\n                    scene: target.scene, // Duck-type validity check\r\n                    takeDamage: (amt: number) => { if (target && target.takeDamage) target.takeDamage(amt); }\r\n                };\r\n\r\n                this.scene.time.delayedCall(delay, () => {\r\n                    if (unit.scene && target.scene) { // Validity check\r\n                        this.fireProjectile(unit, targetVaried, damagePerArrow);\r\n                    }\r\n                });\r\n            }\r\n\r\n        } else {\r\n            // Melee Lunge visual\r\n            const visual = unit.visual;\r\n            if (visual) {\r\n                const angle = Phaser.Math.Angle.Between(unit.x, unit.y, target.x, target.y);\r\n                const ox = visual.x;\r\n                const oy = visual.y;\r\n                const lungeX = ox + Math.cos(angle) * 10;\r\n                const lungeY = oy + Math.sin(angle) * 5; // Iso squash\r\n\r\n                this.scene.tweens.add({\r\n                    targets: visual,\r\n                    x: lungeX,\r\n                    y: lungeY,\r\n                    duration: 100,\r\n                    yoyo: true,\r\n                    onComplete: () => {\r\n                        // Reset position exactly to avoid drift\r\n                        const iso = toIso(unit.x, unit.y);\r\n                        visual.setPosition(iso.x, iso.y);\r\n                    }\r\n                });\r\n            }\r\n\r\n            // Apply Damage Immediately (Melee)\r\n            if (target.takeDamage) {\r\n                target.takeDamage(dmg);\r\n            }\r\n        }\r\n    }\r\n\r\n    private fireProjectile(unit: any, target: any, dmg: number) {\r\n        const startIso = toIso(unit.x, unit.y);\r\n        const endIso = toIso(target.x, target.y);\r\n\r\n        // Visual: Arrow (WHITE)\r\n        const arrow = this.scene.add.rectangle(startIso.x, startIso.y - 20, 10, 1, 0xffffff);\r\n        arrow.setDepth(startIso.y + 100);\r\n\r\n        // Visual: Trail Effect (WHITE, LONGER)\r\n        const emitter = this.scene.add.particles(0, 0, 'white_flare', {\r\n            speed: 0,\r\n            scale: { start: 0.2, end: 0 },\r\n            alpha: { start: 0.8, end: 0 },\r\n            lifespan: 500, // Longer trail\r\n            tint: 0xffffff, // White trail\r\n            blendMode: 'ADD',\r\n            frequency: 10,\r\n            follow: arrow\r\n        });\r\n        emitter.setDepth(Number.MAX_VALUE - 100);\r\n\r\n        // Parabolic arc simulation\r\n        // We tween X and Y linearly for ground movement\r\n        // We use a custom update or a separate tween for 'height' to simulate arc\r\n\r\n        // Simple linear movement for now, with a \"height\" offset curve?\r\n        // Actually, just standard Phaser tween with a custom onUpdate is easy.\r\n\r\n        const midX = (startIso.x + endIso.x) / 2;\r\n        const midY = (startIso.y + endIso.y) / 2 - 50; // Arc peak control point\r\n\r\n        // Or we can use a Quadratic Bezier curve\r\n        const curve = new Phaser.Curves.QuadraticBezier(\r\n            new Phaser.Math.Vector2(startIso.x, startIso.y - 15),\r\n            new Phaser.Math.Vector2(midX, midY - 50), // Peak\r\n            new Phaser.Math.Vector2(endIso.x, endIso.y - 10)\r\n        );\r\n\r\n        const projectileObj = { t: 0, vec: new Phaser.Math.Vector2() };\r\n\r\n        this.scene.tweens.add({\r\n            targets: projectileObj,\r\n            t: 1,\r\n            duration: 800, // Slower flight (was 400)\r\n            onUpdate: () => {\r\n                curve.getPoint(projectileObj.t, projectileObj.vec);\r\n                arrow.setPosition(projectileObj.vec.x, projectileObj.vec.y);\r\n\r\n                // Orient arrow along tangent\r\n                const tangent = curve.getTangent(projectileObj.t);\r\n                arrow.setRotation(tangent.angle());\r\n            },\r\n            onComplete: () => {\r\n                arrow.destroy();\r\n                emitter.destroy();\r\n                // Check if target is still valid before damaging\r\n                if (target.takeDamage) {\r\n                    target.takeDamage(dmg);\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    private drawDebugLines() {\r\n        this.debugGraphics.clear();\r\n        this.scene.units.getChildren().forEach((u: any) => {\r\n            const startIso = toIso(u.x, u.y);\r\n\r\n            // Draw Target Lines (Combat)\r\n            if (u.target && u.target.scene) {\r\n                const endIso = toIso(u.target.x, u.target.y);\r\n                this.debugGraphics.lineStyle(2, 0xff0000, 0.7);\r\n                this.debugGraphics.beginPath();\r\n                this.debugGraphics.moveTo(startIso.x, startIso.y);\r\n                this.debugGraphics.lineTo(endIso.x, endIso.y);\r\n                this.debugGraphics.strokePath();\r\n            }\r\n\r\n            // Draw Path Lines (Movement)\r\n            if (u.path && u.path.length > 0) {\r\n                const dest = u.path[u.path.length - 1];\r\n                const endIso = toIso(dest.x, dest.y);\r\n                this.debugGraphics.lineStyle(1, 0xffffff, 0.5);\r\n                this.debugGraphics.beginPath();\r\n                this.debugGraphics.moveTo(startIso.x, startIso.y);\r\n                this.debugGraphics.lineTo(endIso.x, endIso.y);\r\n                this.debugGraphics.strokePath();\r\n            }\r\n        });\r\n    }\r\n\r\n    private drawUnitPaths(time: number) {\r\n        this.pathGraphics.clear();\r\n        this.scene.units.getChildren().forEach((uObj: Phaser.GameObjects.GameObject) => {\r\n            const u = uObj as any;\r\n            const isSelectable = [UnitType.SOLDIER, UnitType.CAVALRY, UnitType.LEGION, UnitType.ARCHER].includes(u.unitType);\r\n\r\n            if (isSelectable && u.path && u.pathCreatedAt) {\r\n                const age = time - u.pathCreatedAt;\r\n                const fadeDuration = 1500;\r\n                if (age < fadeDuration) {\r\n                    const alpha = Phaser.Math.Clamp(1 - (age / fadeDuration), 0, 1);\r\n                    if (u.path.length > u.pathStep) {\r\n                        this.pathGraphics.beginPath();\r\n                        const startIso = toIso(u.x, u.y);\r\n                        this.pathGraphics.moveTo(startIso.x, startIso.y);\r\n                        for (let i = u.pathStep; i < u.path.length; i++) {\r\n                            const pt = u.path[i];\r\n                            const iso = toIso(pt.x, pt.y);\r\n                            this.pathGraphics.lineTo(iso.x, iso.y);\r\n                        }\r\n                        this.pathGraphics.lineStyle(2, 0xffffff, alpha);\r\n                        this.pathGraphics.strokePath();\r\n                        this.pathGraphics.lineStyle(6, 0xffffff, alpha * 0.3);\r\n                        this.pathGraphics.strokePath();\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\LGSM228\\CivStrategy\\game\\utils\\SpatialHash.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Phaser' is defined but never used. Allowed unused vars must match /^_/u.","line":2,"column":8,"nodeType":null,"messageId":"unusedVar","endLine":2,"endColumn":14},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":6,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":6,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[130,133],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[130,133],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":19,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":19,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[476,479],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[476,479],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":28,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":28,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[759,762],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[759,762],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":38,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":38,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1073,1076],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1073,1076],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":48,"column":57,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":48,"endColumn":60,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1372,1375],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1372,1375],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":49,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":49,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1404,1407],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1404,1407],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":7,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\r\nimport Phaser from 'phaser';\r\n\r\nexport class SpatialHash {\r\n    private cellSize: number;\r\n    private buckets: Map<string, Set<any>>;\r\n\r\n    constructor(cellSize: number) {\r\n        this.cellSize = cellSize;\r\n        this.buckets = new Map();\r\n    }\r\n\r\n    private getKey(x: number, y: number): string {\r\n        const cx = Math.floor(x / this.cellSize);\r\n        const cy = Math.floor(y / this.cellSize);\r\n        return `${cx},${cy}`;\r\n    }\r\n\r\n    public insert(entity: any) {\r\n        const key = this.getKey(entity.x, entity.y);\r\n        if (!this.buckets.has(key)) {\r\n            this.buckets.set(key, new Set());\r\n        }\r\n        this.buckets.get(key)!.add(entity);\r\n        entity.setData('spatialKey', key);\r\n    }\r\n\r\n    public remove(entity: any) {\r\n        const key = entity.getData('spatialKey');\r\n        if (key && this.buckets.has(key)) {\r\n            this.buckets.get(key)!.delete(entity);\r\n            if (this.buckets.get(key)!.size === 0) {\r\n                this.buckets.delete(key);\r\n            }\r\n        }\r\n    }\r\n\r\n    public update(entity: any) {\r\n        const oldKey = entity.getData('spatialKey');\r\n        const newKey = this.getKey(entity.x, entity.y);\r\n\r\n        if (oldKey !== newKey) {\r\n            this.remove(entity);\r\n            this.insert(entity);\r\n        }\r\n    }\r\n\r\n    public query(x: number, y: number, radius: number): any[] {\r\n        const results: any[] = [];\r\n        const checkedKeys = new Set<string>();\r\n\r\n        // Calculate range of cells to check\r\n        const startX = Math.floor((x - radius) / this.cellSize);\r\n        const endX = Math.floor((x + radius) / this.cellSize);\r\n        const startY = Math.floor((y - radius) / this.cellSize);\r\n        const endY = Math.floor((y + radius) / this.cellSize);\r\n\r\n        for (let cx = startX; cx <= endX; cx++) {\r\n            for (let cy = startY; cy <= endY; cy++) {\r\n                const key = `${cx},${cy}`;\r\n                if (checkedKeys.has(key)) continue;\r\n                checkedKeys.add(key);\r\n\r\n                const bucket = this.buckets.get(key);\r\n                if (bucket) {\r\n                    bucket.forEach(entity => {\r\n                        // Rough check first? No, just return candidates\r\n                        results.push(entity);\r\n                    });\r\n                }\r\n            }\r\n        }\r\n\r\n        return results;\r\n    }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\LGSM228\\CivStrategy\\game\\utils\\iso.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\LGSM228\\CivStrategy\\index.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\LGSM228\\CivStrategy\\types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\LGSM228\\CivStrategy\\vite.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]}]