[{"filePath":"C:\\Users\\LGSM228\\CivStrategy\\App.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\LGSM228\\CivStrategy\\components\\GameUI.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\LGSM228\\CivStrategy\\components\\LoadingScreen.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\LGSM228\\CivStrategy\\components\\MainMenu.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\LGSM228\\CivStrategy\\components\\PhaserGame.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\LGSM228\\CivStrategy\\constants.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\LGSM228\\CivStrategy\\eslint.config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\LGSM228\\CivStrategy\\game\\MainScene.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":265,"column":57,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":265,"endColumn":60,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11043,11046],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11043,11046],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":369,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":369,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15113,15116],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15113,15116],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":377,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":377,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15483,15486],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15483,15486],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\r\nimport Phaser from 'phaser';\r\nimport { EVENTS, INITIAL_RESOURCES, MAP_SIZES, FACTION_COLORS } from '../constants';\r\nimport { BuildingType, FactionType, Resources, UnitType, MapMode, MapSize } from '../types';\r\nimport { toIso } from './utils/iso';\r\nimport { SpatialHash } from './utils/SpatialHash';\r\nimport { Pathfinder } from './systems/Pathfinder';\r\nimport { EntityFactory } from './systems/EntityFactory';\r\nimport { EconomySystem } from './systems/EconomySystem';\r\nimport { UnitSystem } from './systems/UnitSystem';\r\nimport { BuildingManager } from './systems/BuildingManager';\r\nimport { InputManager } from './systems/InputManager';\r\nimport { InfiniteMapSystem } from './systems/InfiniteMapSystem';\r\nimport { FogOfWarSystem } from './systems/FogOfWarSystem';\r\nimport { EnemyAISystem } from './systems/EnemyAISystem';\r\nimport { MinimapSystem } from './systems/MinimapSystem';\r\nimport { SquadSystem } from './systems/SquadSystem';\r\nimport { MapGenerationSystem } from './systems/MapGenerationSystem';\r\nimport { CullingSystem } from './systems/CullingSystem';\r\nimport { FeedbackSystem } from './systems/FeedbackSystem';\r\n\r\n\r\nexport class MainScene extends Phaser.Scene {\r\n\r\n\r\n  // Game State\r\n  public resources: Resources = { ...INITIAL_RESOURCES };\r\n  public population = 0;\r\n  public maxPopulation = 10;\r\n  public happiness = 100;\r\n  public faction: FactionType = FactionType.ROMANS;\r\n  public enemyFaction: FactionType = FactionType.GAULS; // Default Fallback\r\n  public mapMode: MapMode = MapMode.FIXED;\r\n  public mapWidth: number = 2048;\r\n  public mapHeight: number = 2048;\r\n  public taxRate: number = 0;\r\n  public isFowEnabled: boolean = true;\r\n\r\n  // Diplomacy\r\n  public peacefulMode: boolean = false;\r\n  public treatyLength: number = 0; // ms\r\n  public aiDisabled: boolean = false;\r\n\r\n  // Debug\r\n  public debugMode: boolean = false;\r\n  public showUnitIndicators: boolean = true;\r\n  private debugText!: Phaser.GameObjects.Text;\r\n\r\n  // Game Speed & Time\r\n  public gameSpeed: number = 0.5;\r\n  public gameTime: number = 0;\r\n  private accumulatedTime: number = 0;\r\n  private accumulatedPopTime: number = 0;\r\n\r\n  // Core Groups\r\n  public units!: Phaser.GameObjects.Group;\r\n  public buildings!: Phaser.GameObjects.Group;\r\n  public trees!: Phaser.GameObjects.Group;\r\n  public fertileZones: Phaser.Geom.Circle[] = [];\r\n\r\n  // Ground Layer\r\n  private groundLayer!: Phaser.GameObjects.TileSprite;\r\n  private readonly groundScale = 0.08;\r\n\r\n  // Systems\r\n  public pathfinder!: Pathfinder;\r\n  public treeSpatialHash!: SpatialHash;\r\n  public entityFactory!: EntityFactory;\r\n  public economySystem!: EconomySystem;\r\n  public unitSystem!: UnitSystem;\r\n  public buildingManager!: BuildingManager;\r\n  public inputManager!: InputManager;\r\n  public infiniteMapSystem!: InfiniteMapSystem;\r\n  public fogOfWar!: FogOfWarSystem | null;\r\n  public enemyAI!: EnemyAISystem;\r\n  public minimapSystem!: MinimapSystem;\r\n  public squadSystem!: SquadSystem;\r\n  public mapGenerationSystem!: MapGenerationSystem;\r\n  public cullingSystem!: CullingSystem;\r\n  public feedbackSystem!: FeedbackSystem;\r\n\r\n  public treeVisuals!: Phaser.GameObjects.Group; // Pool for tree visuals\r\n\r\n  // Input Keys\r\n  public cursors!: Phaser.Types.Input.Keyboard.CursorKeys;\r\n  public wasd!: {\r\n    W: Phaser.Input.Keyboard.Key;\r\n    A: Phaser.Input.Keyboard.Key;\r\n    S: Phaser.Input.Keyboard.Key;\r\n    D: Phaser.Input.Keyboard.Key;\r\n  };\r\n\r\n  public getFactionColor(owner: number): number {\r\n    if (owner === 0) return FACTION_COLORS[this.faction];\r\n    if (owner === 1) return FACTION_COLORS[this.enemyFaction];\r\n    return 0xffffff;\r\n  }\r\n\r\n  constructor() {\r\n    super('MainScene');\r\n  }\r\n\r\n  preload() {\r\n    // Dispatch progress to React\r\n    this.load.on('progress', (value: number) => {\r\n      window.dispatchEvent(new CustomEvent('game-load-progress', { detail: value }));\r\n    });\r\n\r\n    this.load.on('complete', () => {\r\n      window.dispatchEvent(new CustomEvent('game-load-complete'));\r\n    });\r\n\r\n    this.load.image('ground', 'https://i.imgur.com/4P6C0Q3.jpeg');\r\n    this.load.image('lumber', 'https://i.imgur.com/SyKc69J.png');\r\n    this.load.image('townhall', 'https://i.imgur.com/kMBtb9W.png');\r\n    this.load.image('field', 'https://i.imgur.com/uPjycje.png');\r\n    this.load.image('flare', 'https://labs.phaser.io/assets/particles/flare.png');\r\n    this.load.image('tree', 'https://i.imgur.com/tYIgx0v.png');\r\n    this.load.image('stump', 'https://i.imgur.com/bEjOzbv.png');\r\n    this.load.image('house', 'https://i.imgur.com/Ix1nDUv.png');\r\n    this.load.image('lodge', 'https://i.ibb.co.com/4nGGymPZ/hunterslodge.png');\r\n    this.load.image('smoke', 'https://labs.phaser.io/assets/particles/smoke-puff.png');\r\n  }\r\n\r\n  init(data: { faction?: FactionType, mapMode?: MapMode, fowEnabled?: boolean, peacefulMode?: boolean, treatyLength?: number, mapSize?: MapSize, aiDisabled?: boolean }) {\r\n    this.faction = data.faction || FactionType.ROMANS;\r\n    this.mapMode = data.mapMode || MapMode.FIXED;\r\n    this.isFowEnabled = data.fowEnabled !== undefined ? data.fowEnabled : true;\r\n    this.peacefulMode = data.peacefulMode === true;\r\n    this.treatyLength = (data.treatyLength || 0) * 60 * 1000;\r\n\r\n    // Pick a random enemy faction that is NOT the player's faction\r\n    const allFactions = Object.values(FactionType) as FactionType[];\r\n    const available = allFactions.filter(f => f !== this.faction);\r\n    this.enemyFaction = available[Phaser.Math.Between(0, available.length - 1)];\r\n\r\n    if (this.mapMode === MapMode.FIXED) {\r\n      const sizePx = MAP_SIZES[(data.mapSize || MapSize.MEDIUM) as MapSize];\r\n      this.mapWidth = sizePx;\r\n      this.mapHeight = sizePx;\r\n    } else {\r\n      this.mapWidth = 2048;\r\n      this.mapHeight = 2048;\r\n    }\r\n    this.resources = { ...INITIAL_RESOURCES };\r\n    this.population = 0;\r\n    this.maxPopulation = 5;\r\n    this.happiness = 100;\r\n    this.taxRate = 0;\r\n    this.gameSpeed = 0.5;\r\n    this.aiDisabled = data.aiDisabled === true;\r\n  }\r\n\r\n  create() {\r\n    this.game.canvas.oncontextmenu = (e) => e.preventDefault();\r\n\r\n    // Generate robust textures\r\n    if (!this.textures.exists('white_flare')) {\r\n      const graphics = this.make.graphics({ x: 0, y: 0 });\r\n      graphics.fillStyle(0xffffff, 1);\r\n      graphics.fillCircle(4, 4, 4);\r\n      graphics.generateTexture('white_flare', 8, 8);\r\n    }\r\n    this.pathfinder = new Pathfinder();\r\n    this.treeSpatialHash = new SpatialHash(250); // 250px cells (approx 1-2 trees width)\r\n    this.entityFactory = new EntityFactory(this);\r\n    this.squadSystem = new SquadSystem(this);\r\n\r\n    this.groundLayer = this.add.tileSprite(0, 0, this.scale.width, this.scale.height, 'ground');\r\n    this.groundLayer.setOrigin(0, 0);\r\n    this.groundLayer.setDepth(-20000);\r\n    this.groundLayer.setTileScale(this.groundScale);\r\n\r\n    this.units = this.add.group({ runChildUpdate: true });\r\n    this.buildings = this.add.group();\r\n    this.trees = this.add.group();\r\n    this.treeVisuals = this.add.group(); // Visual pool\r\n\r\n    // Hook into tree group to maintain spatial hash\r\n    this.trees.on('create', (item: Phaser.GameObjects.GameObject) => this.treeSpatialHash.insert(item));\r\n    this.trees.on('remove', (item: Phaser.GameObjects.GameObject) => this.treeSpatialHash.remove(item));\r\n\r\n\r\n    this.unitSystem = new UnitSystem(this);\r\n    this.buildingManager = new BuildingManager(this);\r\n    this.economySystem = new EconomySystem(this);\r\n    this.inputManager = new InputManager(this);\r\n    this.enemyAI = new EnemyAISystem(this);\r\n    this.mapGenerationSystem = new MapGenerationSystem(this);\r\n    this.cullingSystem = new CullingSystem(this);\r\n    this.feedbackSystem = new FeedbackSystem(this);\r\n\r\n    if (this.mapMode === MapMode.FIXED) {\r\n      this.physics.world.setBounds(0, 0, this.mapWidth, this.mapHeight);\r\n      this.mapGenerationSystem.createEnvironment();\r\n      this.mapGenerationSystem.generateFertileZones();\r\n      this.mapGenerationSystem.generateForestsAndAnimals();\r\n    } else {\r\n      this.physics.world.setBounds(-100000, -100000, 200000, 200000);\r\n      this.infiniteMapSystem = new InfiniteMapSystem(this);\r\n    }\r\n\r\n    const centerX = this.mapMode === MapMode.FIXED ? this.mapWidth / 2 : 400;\r\n    const centerY = this.mapMode === MapMode.FIXED ? this.mapHeight / 2 : 400;\r\n\r\n    this.entityFactory.spawnBuilding(BuildingType.TOWN_CENTER, centerX, centerY, 0);\r\n    this.entityFactory.spawnBuilding(BuildingType.BONFIRE, centerX + 80, centerY, 0);\r\n    this.entityFactory.spawnUnit(UnitType.VILLAGER, centerX + 50, centerY + 50, 0);\r\n    this.entityFactory.spawnUnit(UnitType.VILLAGER, centerX - 50, centerY + 50, 0);\r\n    this.entityFactory.spawnUnit(UnitType.CAVALRY, centerX, centerY + 90, 0);\r\n\r\n    // Spawn a squad of Archers\r\n    for (let i = 0; i < 5; i++) {\r\n      this.entityFactory.spawnUnit(UnitType.ARCHER, centerX - 60 + (i * 15), centerY + 80, 0);\r\n    }\r\n\r\n    // DEBUG: Spawn Enemy Barracks for Target Practice\r\n    this.entityFactory.spawnBuilding(BuildingType.BARRACKS, centerX + 300, centerY, 1);\r\n\r\n    const startIso = toIso(centerX, centerY);\r\n    this.cameras.main.centerOn(startIso.x, startIso.y);\r\n    this.cameras.main.setBackgroundColor('#0d1117');\r\n\r\n    this.cursors = this.input.keyboard!.createCursorKeys();\r\n    this.wasd = this.input.keyboard!.addKeys('W,A,S,D') as { W: Phaser.Input.Keyboard.Key; A: Phaser.Input.Keyboard.Key; S: Phaser.Input.Keyboard.Key; D: Phaser.Input.Keyboard.Key; };\r\n\r\n    this.debugText = this.add.text(10, 80, '', {\r\n      font: '14px monospace', color: '#00ff00', backgroundColor: '#000000bb', padding: { x: 10, y: 10 }\r\n    }).setScrollFactor(0).setDepth(99999).setVisible(false);\r\n\r\n    this.input.keyboard!.on('keydown-F3', () => {\r\n      this.debugMode = !this.debugMode;\r\n      this.debugText.setVisible(this.debugMode);\r\n    });\r\n\r\n    this.input.keyboard!.on('keydown-I', () => {\r\n      this.showUnitIndicators = !this.showUnitIndicators;\r\n    });\r\n\r\n    this.game.events.on('request-soldier-spawn', this.handleSoldierSpawnRequest, this);\r\n    this.game.events.on(EVENTS.SET_TAX_RATE, (rate: number) => { this.taxRate = rate; this.economySystem.updateStats(); }, this);\r\n    this.game.events.on(EVENTS.CENTER_CAMERA, this.centerCameraOnTownCenter, this);\r\n    this.game.events.on(EVENTS.SET_GAME_SPEED, (speed: number) => {\r\n      this.gameSpeed = speed;\r\n      this.physics.world.timeScale = 1 / speed;\r\n      this.tweens.timeScale = speed;\r\n    }, this);\r\n\r\n    this.physics.world.timeScale = 1 / this.gameSpeed;\r\n    this.economySystem.updateStats();\r\n\r\n    if (this.isFowEnabled) { this.fogOfWar = new FogOfWarSystem(this); } else { this.fogOfWar = null; }\r\n    this.minimapSystem = new MinimapSystem(this);\r\n\r\n    const minimapClickHandler = (e: Event) => {\r\n      const detail = (e as CustomEvent).detail;\r\n      this.handleMinimapClick(detail.x, detail.y);\r\n    };\r\n    window.addEventListener('minimap-click-ui', minimapClickHandler);\r\n  }\r\n\r\n  private lastTcIndex = -1;\r\n\r\n  public centerCameraOnTownCenter() {\r\n    const tcs = this.buildings.getChildren().filter((b: any) =>\r\n      b.getData('def').type === BuildingType.TOWN_CENTER && b.getData('owner') === 0\r\n    ) as Phaser.GameObjects.Rectangle[];\r\n    if (tcs.length === 0) return;\r\n    this.lastTcIndex = (this.lastTcIndex + 1) % tcs.length;\r\n    const target = tcs[this.lastTcIndex];\r\n    if (target) {\r\n      const iso = toIso(target.x, target.y);\r\n      this.cameras.main.pan(iso.x, iso.y, 1000, 'Power2');\r\n    }\r\n  }\r\n\r\n  public handleMinimapClick(mx: number, my: number) {\r\n    if (!this.minimapSystem) return;\r\n    const worldPos = this.minimapSystem.getWorldFromMinimap(mx, my);\r\n    const iso = toIso(worldPos.x, worldPos.y);\r\n    this.cameras.main.pan(iso.x, iso.y, 500, 'Power2');\r\n  }\r\n\r\n  update(time: number, delta: number) {\r\n    const dt = delta * this.gameSpeed;\r\n    this.gameTime += dt;\r\n\r\n    if (this.debugMode) {\r\n      // const treatySecs = Math.max(0, Math.ceil((this.treatyLength - this.gameTime) / 1000));\r\n      this.debugText.setText([\r\n        `FPS: ${this.game.loop.actualFps.toFixed(1)}`,\r\n        `Speed: ${this.gameSpeed}x`,\r\n        // Fix: Cast GameObject to any to access 'visible' property for debug HUD reporting\r\n        `Units: ${this.units.getLength()} | Visible: ${this.units.getChildren().filter(u => (u as unknown as Phaser.GameObjects.Components.Visible).visible).length}`,\r\n        `Trees: ${this.trees.getLength()} | Visible: ${this.trees.getChildren().filter(t => (t as unknown as Phaser.GameObjects.Components.Visible).visible).length}`,\r\n        `AI: ${this.enemyAI.getDebugInfo()}`\r\n      ]);\r\n    }\r\n\r\n    this.inputManager.update(delta);\r\n\r\n    const cam = this.cameras.main;\r\n    const topLeft = cam.getWorldPoint(0, 0);\r\n    const bottomRight = cam.getWorldPoint(cam.width, cam.height);\r\n    const width = bottomRight.x - topLeft.x;\r\n    const height = bottomRight.y - topLeft.y;\r\n\r\n    this.groundLayer.setPosition(topLeft.x, topLeft.y);\r\n    this.groundLayer.setSize(width, height);\r\n    this.groundLayer.tilePositionX = topLeft.x / this.groundScale;\r\n    this.groundLayer.tilePositionY = topLeft.y / this.groundScale;\r\n\r\n    this.groundLayer.tilePositionY = topLeft.y / this.groundScale;\r\n\r\n    this.cullingSystem.update(delta);\r\n\r\n    this.unitSystem.update(this.gameTime, dt);\r\n    this.squadSystem.update(dt);\r\n    this.buildingManager.update();\r\n    if (!this.aiDisabled) {\r\n      this.enemyAI.update(this.gameTime, dt);\r\n    }\r\n\r\n    if (this.infiniteMapSystem) this.infiniteMapSystem.update();\r\n    if (this.minimapSystem) this.minimapSystem.update();\r\n    if (this.fogOfWar) this.fogOfWar.update();\r\n\r\n    this.accumulatedTime += dt;\r\n    if (this.accumulatedTime >= 1000) {\r\n      this.economySystem.tickEconomy();\r\n      this.accumulatedTime -= 1000;\r\n    }\r\n\r\n    this.accumulatedPopTime += dt;\r\n    if (this.accumulatedPopTime >= 5000) {\r\n      this.economySystem.tickPopulation();\r\n      this.accumulatedPopTime -= 5000;\r\n    }\r\n\r\n    this.economySystem.assignJobs();\r\n    this.syncVisuals();\r\n  }\r\n\r\n\r\n\r\n  handleSoldierSpawnRequest() {\r\n\r\n    if (this.resources.food >= 100 && this.resources.gold >= 50) {\r\n      const barracks = this.buildings.getChildren().filter((b) => b.getData('def').type === BuildingType.BARRACKS && b.getData('owner') === 0) as Phaser.GameObjects.Rectangle[];\r\n      if (barracks.length > 0) {\r\n        const spawnSource = barracks[Phaser.Math.Between(0, barracks.length - 1)];\r\n        this.resources.food -= 100;\r\n        this.resources.gold -= 50;\r\n        const spawnX = spawnSource.x + 60;\r\n        const spawnY = spawnSource.y + 60;\r\n        this.entityFactory.spawnUnit(UnitType.SOLDIER, spawnX, spawnY, 0);\r\n        this.economySystem.updateStats();\r\n      } else {\r\n        this.feedbackSystem.showFloatingText(this.cameras.main.worldView.centerX, this.cameras.main.worldView.centerY, \"Build a Barracks first!\", \"#ff0000\");\r\n\r\n      }\r\n    }\r\n  }\r\n\r\n  syncVisuals() {\r\n    this.units.getChildren().forEach((u) => {\r\n      // Fix: Use any-cast to safely check 'visible' property on generic units\r\n      const unit = u as Phaser.GameObjects.Sprite;\r\n      const visual = (u as any).visual; // eslint-disable-line @typescript-eslint/no-explicit-any\r\n      if (visual && (visual as Phaser.GameObjects.Components.Visible).visible) {\r\n        const iso = toIso(unit.x, unit.y);\r\n        visual.setPosition(iso.x, iso.y);\r\n        visual.setDepth(iso.y);\r\n      }\r\n    });\r\n    this.buildings.getChildren().forEach((b) => {\r\n      const visual = (b as any).visual; // eslint-disable-line @typescript-eslint/no-explicit-any\r\n      if (visual) {\r\n        const iso = toIso((b as Phaser.GameObjects.Image).x, (b as Phaser.GameObjects.Image).y);\r\n        visual.setDepth(iso.y);\r\n      }\r\n    });\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\LGSM228\\CivStrategy\\game\\systems\\BuildingManager.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":216,"column":51,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":216,"endColumn":54,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9179,9182],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9179,9182],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":236,"column":51,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":236,"endColumn":54,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10140,10143],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10140,10143],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":272,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":272,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11584,11587],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11584,11587],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'buildingWidth' is defined but never used. Allowed unused args must match /^_/u.","line":284,"column":63,"nodeType":null,"messageId":"unusedVar","endLine":284,"endColumn":76},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":353,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":353,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14275,14278],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14275,14278],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":71,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":71,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2923,2926],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2923,2926],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":205,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":205,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8639,8642],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8639,8642],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":5,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\r\nimport Phaser from 'phaser';\r\nimport { MainScene } from '../MainScene';\r\nimport { BuildingType, BuildingDef, UnitState, UnitType } from '../../types';\r\nimport { BUILDINGS, EVENTS, TILE_SIZE } from '../../constants';\r\nimport { toIso, toCartesian } from '../utils/iso';\r\n\r\nexport class BuildingManager {\r\n    private scene: MainScene;\r\n    public previewBuilding: Phaser.GameObjects.Container | null = null;\r\n    public previewBuildingType: BuildingType | null = null;\r\n    public isDemolishMode: boolean = false;\r\n    private treeHighlightGraphics: Phaser.GameObjects.Graphics;\r\n    private territoryGraphics: Phaser.GameObjects.Graphics;\r\n    private isTerritoryDirty: boolean = true;\r\n\r\n    constructor(scene: MainScene) {\r\n        this.scene = scene;\r\n        this.treeHighlightGraphics = this.scene.add.graphics().setDepth(Number.MAX_VALUE - 500);\r\n        this.territoryGraphics = this.scene.add.graphics().setDepth(-5000);\r\n\r\n        this.scene.game.events.on('request-build', this.enterBuildMode, this);\r\n        this.scene.game.events.on(EVENTS.TOGGLE_DEMOLISH, this.toggleDemolishMode, this);\r\n        this.scene.game.events.on(EVENTS.REGROW_FOREST, this.handleRegrowForest, this);\r\n        this.scene.game.events.on(EVENTS.DEMOLISH_SELECTED, this.handleDemolishSelected, this);\r\n    }\r\n\r\n    public update() {\r\n        if (this.isTerritoryDirty) {\r\n            this.drawTerritory();\r\n            this.isTerritoryDirty = false;\r\n        }\r\n    }\r\n\r\n    public markTerritoryDirty() {\r\n        this.isTerritoryDirty = true;\r\n    }\r\n\r\n    public enterBuildMode(buildingType: BuildingType) {\r\n        const def = BUILDINGS[buildingType];\r\n        if (!def) return;\r\n\r\n        if (this.isDemolishMode) {\r\n            this.toggleDemolishMode(false);\r\n            this.scene.game.events.emit(EVENTS.TOGGLE_DEMOLISH, false);\r\n        }\r\n\r\n        if (this.previewBuilding) this.previewBuilding.destroy();\r\n        this.previewBuildingType = buildingType;\r\n        this.previewBuilding = this.scene.add.container(0, 0);\r\n        const gfx = this.scene.add.graphics();\r\n        this.scene.entityFactory.drawIsoBuilding(gfx, def, 0xffffff, 0.5);\r\n        this.previewBuilding.add(gfx);\r\n        this.previewBuilding.setDepth(Number.MAX_VALUE);\r\n        this.previewBuilding.setVisible(false);\r\n    }\r\n\r\n    public toggleDemolishMode(isActive: boolean) {\r\n        this.isDemolishMode = isActive;\r\n        if (this.isDemolishMode) {\r\n            this.scene.inputManager.clearSelection();\r\n            this.previewBuildingType = null;\r\n            if (this.previewBuilding) {\r\n                this.previewBuilding.destroy();\r\n                this.previewBuilding = null;\r\n            }\r\n            this.scene.input.setDefaultCursor('crosshair');\r\n        } else {\r\n            this.scene.input.setDefaultCursor('default');\r\n            this.scene.buildings.getChildren().forEach((b) => {\r\n                const visual = (b as any).visual as Phaser.GameObjects.Container; // eslint-disable-line @typescript-eslint/no-explicit-any\r\n                if (visual) {\r\n                    const highlight = visual.getData('demolishHighlight') as Phaser.GameObjects.Graphics;\r\n                    if (highlight) {\r\n                        highlight.destroy();\r\n                        visual.setData('demolishHighlight', null);\r\n                    }\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    public updatePreview(worldX: number, worldY: number) {\r\n        if (!this.previewBuildingType || !this.previewBuilding) return;\r\n\r\n        this.previewBuilding.setVisible(true);\r\n\r\n        const cart = toCartesian(worldX, worldY);\r\n        const gx = Math.floor(cart.x / TILE_SIZE) * TILE_SIZE;\r\n        const gy = Math.floor(cart.y / TILE_SIZE) * TILE_SIZE;\r\n        const def = BUILDINGS[this.previewBuildingType];\r\n        const cx = gx + def.width / 2;\r\n        const cy = gy + def.height / 2;\r\n\r\n        const iso = toIso(cx, cy);\r\n        this.previewBuilding.setPosition(iso.x, iso.y);\r\n        this.previewBuilding.setDepth(Number.MAX_VALUE - 100);\r\n\r\n        const isValid = this.checkBuildValidity(cx, cy, this.previewBuildingType);\r\n        const color = isValid ? 0x00ff00 : 0xff0000;\r\n\r\n        const graphics = this.previewBuilding.getAt(0) as Phaser.GameObjects.Graphics;\r\n        graphics.clear();\r\n\r\n        if (def.effectRadius) {\r\n            graphics.lineStyle(2, 0xffd700, 0.8);\r\n            graphics.strokeEllipse(0, 0, def.effectRadius * 2, def.effectRadius);\r\n            graphics.fillStyle(0xffd700, 0.1);\r\n            graphics.fillEllipse(0, 0, def.effectRadius * 2, def.effectRadius);\r\n        }\r\n\r\n        this.treeHighlightGraphics.clear();\r\n        this.updateHighlights(cx, cy, def);\r\n\r\n        this.scene.entityFactory.drawIsoBuilding(graphics, def, color, 0.5);\r\n    }\r\n\r\n    private updateHighlights(cx: number, cy: number, def: BuildingDef) {\r\n        if (this.previewBuildingType === BuildingType.LUMBER_CAMP) {\r\n            const range = def.effectRadius || 200;\r\n            this.scene.trees.getChildren().forEach((t) => {\r\n                const tx = (t as Phaser.GameObjects.Image).x;\r\n                const ty = (t as Phaser.GameObjects.Image).y;\r\n                if (Phaser.Math.Distance.Between(cx, cy, tx, ty) <= range) {\r\n                    const isoT = toIso(tx, ty);\r\n                    this.treeHighlightGraphics.lineStyle(2, 0x4ade80, 0.8);\r\n                    this.treeHighlightGraphics.strokeCircle(isoT.x, isoT.y, 15);\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    public tryBuild(worldX: number, worldY: number) {\r\n        if (!this.previewBuildingType) return;\r\n\r\n        const cart = toCartesian(worldX, worldY);\r\n        const gx = Math.floor(cart.x / TILE_SIZE) * TILE_SIZE;\r\n        const gy = Math.floor(cart.y / TILE_SIZE) * TILE_SIZE;\r\n        const def = BUILDINGS[this.previewBuildingType];\r\n        const cx = gx + def.width / 2;\r\n        const cy = gy + def.height / 2;\r\n\r\n        if (this.checkBuildValidity(cx, cy, this.previewBuildingType)) {\r\n            this.scene.entityFactory.spawnBuilding(this.previewBuildingType, cx, cy);\r\n\r\n            // Juice: Screen shake (subtle)\r\n            this.scene.cameras.main.shake(80, 0.003);\r\n\r\n            // Juice: Dust particles poof\r\n            const iso = toIso(cx, cy);\r\n            this.emitDustParticles(iso.x, iso.y, def.width);\r\n\r\n            this.scene.resources.wood -= def.cost.wood;\r\n            this.scene.resources.food -= def.cost.food;\r\n            this.scene.resources.gold -= def.cost.gold;\r\n\r\n            if (this.previewBuildingType === BuildingType.HOUSE) {\r\n                this.scene.entityFactory.spawnUnit(UnitType.VILLAGER, cx + 30, cy + 30);\r\n                this.scene.feedbackSystem.showFloatingText(cx, cy, \"Peasant spawned!\", \"#00ff00\");\r\n            }\r\n\r\n\r\n            this.markTerritoryDirty();\r\n            this.scene.economySystem.updateStats();\r\n        }\r\n    }\r\n\r\n    private checkBuildValidity(x: number, y: number, type: BuildingType): boolean {\r\n        const def = BUILDINGS[type];\r\n\r\n        if (this.scene.resources.wood < def.cost.wood || this.scene.resources.food < def.cost.food || this.scene.resources.gold < def.cost.gold) {\r\n            return false;\r\n        }\r\n\r\n        let inTerritory = false;\r\n        this.scene.buildings.getChildren().forEach((b) => {\r\n            const bDef = b.getData('def') as BuildingDef;\r\n            if (bDef.territoryRadius) {\r\n                const dist = Phaser.Math.Distance.Between(x, y, (b as Phaser.GameObjects.Image).x, (b as Phaser.GameObjects.Image).y);\r\n                if (dist <= bDef.territoryRadius) inTerritory = true;\r\n            }\r\n        });\r\n        if (!inTerritory && this.scene.buildings.getLength() > 0) return false;\r\n\r\n        const bounds = new Phaser.Geom.Rectangle(x - def.width / 2, y - def.height / 2, def.width, def.height);\r\n        let overlaps = false;\r\n        this.scene.buildings.getChildren().forEach((b) => {\r\n            if (Phaser.Geom.Intersects.RectangleToRectangle(bounds, (b as Phaser.GameObjects.Image).getBounds())) {\r\n                overlaps = true;\r\n            }\r\n        });\r\n        if (overlaps) return false;\r\n\r\n        let treeOverlap = false;\r\n        this.scene.trees.getChildren().forEach((t) => {\r\n            if (bounds.contains((t as Phaser.GameObjects.Image).x, (t as Phaser.GameObjects.Image).y)) treeOverlap = true;\r\n        });\r\n        if (treeOverlap) return false;\r\n\r\n        return true;\r\n    }\r\n\r\n    public handleDemolishHover(pointer: Phaser.Input.Pointer) {\r\n        this.scene.buildings.getChildren().forEach((b) => {\r\n            const visual = (b as any).visual as Phaser.GameObjects.Container; // eslint-disable-line @typescript-eslint/no-explicit-any\r\n            if (visual) {\r\n                const highlight = visual.getData('demolishHighlight') as Phaser.GameObjects.Graphics;\r\n                if (highlight) {\r\n                    highlight.destroy();\r\n                    visual.setData('demolishHighlight', null);\r\n                }\r\n            }\r\n        });\r\n\r\n        const targets = this.scene.input.hitTestPointer(pointer);\r\n        const buildingVisual = targets.find((obj: any) => obj.getData && obj.getData('building')) as Phaser.GameObjects.Container | undefined;\r\n\r\n        if (buildingVisual) {\r\n            const b = buildingVisual.getData('building');\r\n            if (b) {\r\n                // Fix: Only allow demolishing player buildings (owner 0)\r\n                const owner = b.getData('owner');\r\n                if (owner === 0) {\r\n                    const def = b.getData('def') as BuildingDef;\r\n                    const highlight = this.scene.add.graphics();\r\n                    this.scene.entityFactory.drawIsoBuilding(highlight, def, 0xff0000, 0.5);\r\n                    buildingVisual.add(highlight);\r\n                    buildingVisual.setData('demolishHighlight', highlight);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public handleDemolishClick(pointer: Phaser.Input.Pointer) {\r\n        const targets = this.scene.input.hitTestPointer(pointer);\r\n        const buildingVisual = targets.find((obj: any) => obj.getData && obj.getData('building'));\r\n        if (buildingVisual) {\r\n            const b = buildingVisual.getData('building');\r\n            // Fix: Security check before demolition\r\n            const owner = b.getData('owner');\r\n            if (owner === 0) {\r\n                this.demolishBuilding(b);\r\n            }\r\n        }\r\n    }\r\n\r\n    private demolishBuilding(b: Phaser.GameObjects.GameObject) {\r\n        const def = b.getData('def') as BuildingDef;\r\n        const owner = b.getData('owner');\r\n\r\n        if (def.cost.wood > 0) this.scene.resources.wood += Math.floor(def.cost.wood * 0.75);\r\n\r\n        // FIX: Only reduce maxPopulation if it was a player building\r\n        if (owner === 0 && def.populationBonus) this.scene.maxPopulation -= def.populationBonus;\r\n        if (owner === 0 && def.happinessBonus) this.scene.happiness -= def.happinessBonus;\r\n\r\n        const worker = b.getData('assignedWorker');\r\n        if (worker) {\r\n            worker.state = UnitState.IDLE;\r\n            worker.jobBuilding = null;\r\n            worker.path = null;\r\n            worker.body.setVelocity(0, 0);\r\n        }\r\n\r\n        const logic = b as Phaser.GameObjects.Rectangle;\r\n        this.scene.pathfinder.markGrid(logic.x, logic.y, def.width, def.height, false);\r\n\r\n        // Explosion Effect\r\n        const iso = toIso(logic.x, logic.y);\r\n        this.emitExplosionParticles(iso.x, iso.y, def.width);\r\n\r\n        const visual = (b as any).visual;\r\n        if (visual) visual.destroy();\r\n        b.destroy();\r\n\r\n        if (this.scene.inputManager.selectedBuilding === b) {\r\n            this.scene.inputManager.deselectBuilding();\r\n        }\r\n\r\n        this.markTerritoryDirty();\r\n        this.scene.economySystem.updateStats();\r\n    }\r\n\r\n    public emitExplosionParticles(isoX: number, isoY: number, buildingWidth: number) {\r\n        // Larger, more dramatic explosion for demolition/destruction\r\n        const count = 30;\r\n        const emitter = this.scene.add.particles(isoX, isoY, 'smoke', {\r\n            speed: { min: 100, max: 200 },\r\n            angle: { min: 0, max: 360 },\r\n            scale: { start: 0.5, end: 0 },\r\n            alpha: { start: 1, end: 0 },\r\n            lifespan: 1200,\r\n            gravityY: -50,\r\n            blendMode: 'ADD',\r\n            emitting: false\r\n        });\r\n        emitter.setDepth(Number.MAX_VALUE - 5);\r\n\r\n        // Fire burst\r\n        const fireEmitter = this.scene.add.particles(isoX, isoY, 'flare', {\r\n            speed: { min: 50, max: 150 },\r\n            angle: { min: 0, max: 360 },\r\n            scale: { start: 0.3, end: 0 },\r\n            alpha: { start: 0.8, end: 0 },\r\n            tint: 0xff4500, // Orange-Red fire color\r\n            lifespan: 800,\r\n            blendMode: 'ADD',\r\n            emitting: false\r\n        });\r\n        fireEmitter.setDepth(Number.MAX_VALUE - 5);\r\n\r\n        emitter.explode(count);\r\n        fireEmitter.explode(20);\r\n\r\n        // Shake camera for impact\r\n        this.scene.cameras.main.shake(150, 0.005);\r\n\r\n        this.scene.time.delayedCall(1500, () => {\r\n            emitter.destroy();\r\n            fireEmitter.destroy();\r\n        });\r\n    }\r\n\r\n    private handleDemolishSelected() {\r\n        const selected = this.scene.inputManager.selectedBuilding;\r\n        if (!selected) return;\r\n\r\n        // Security check\r\n        const owner = selected.getData('owner');\r\n        if (owner === 0) {\r\n            this.demolishBuilding(selected);\r\n        }\r\n    }\r\n\r\n    private handleRegrowForest() {\r\n        const b = this.scene.inputManager.selectedBuilding as Phaser.GameObjects.Rectangle;\r\n        if (!b) return;\r\n\r\n        const def = b.getData('def') as BuildingDef;\r\n        if (def.type !== BuildingType.LUMBER_CAMP) return;\r\n\r\n        const cost = 50;\r\n        if (this.scene.resources.wood < cost) {\r\n            this.scene.feedbackSystem.showFloatingText(b.x, b.y, \"Not enough wood!\", \"#ff0000\");\r\n            return;\r\n        }\r\n\r\n\r\n        this.scene.resources.wood -= cost;\r\n\r\n        let regrownCount = 0;\r\n        this.scene.trees.getChildren().forEach((tObj: Phaser.GameObjects.GameObject) => {\r\n            const t = tObj as any;\r\n            if (t.getData('isChopped')) {\r\n                if (Phaser.Math.Distance.Between(b.x, b.y, t.x, t.y) < (def.effectRadius || 200)) {\r\n                    this.scene.entityFactory.updateTreeVisual(t, false);\r\n                    regrownCount++;\r\n                }\r\n            }\r\n        });\r\n\r\n        if (regrownCount > 0) {\r\n            this.scene.feedbackSystem.showFloatingText(b.x, b.y, \"Forest Regrown!\", \"#4ade80\");\r\n            this.scene.economySystem.updateStats();\r\n        } else {\r\n            this.scene.feedbackSystem.showFloatingText(b.x, b.y, \"No stumps nearby.\", \"#ffffff\");\r\n            this.scene.resources.wood += cost;\r\n        }\r\n\r\n    }\r\n\r\n    private drawTerritory() {\r\n        this.territoryGraphics.clear();\r\n        this.scene.buildings.getChildren().forEach((bObj: Phaser.GameObjects.GameObject) => {\r\n            const b = bObj as Phaser.GameObjects.Rectangle;\r\n            const def = b.getData('def') as BuildingDef;\r\n            const iso = toIso(b.x, b.y);\r\n            if (def.territoryRadius) {\r\n                const color = this.scene.getFactionColor(b.getData('owner'));\r\n                this.territoryGraphics.fillStyle(color, 0.1);\r\n                this.territoryGraphics.lineStyle(1, color, 0.3);\r\n                this.territoryGraphics.fillEllipse(iso.x, iso.y, def.territoryRadius * 2, def.territoryRadius);\r\n                this.territoryGraphics.strokeEllipse(iso.x, iso.y, def.territoryRadius * 2, def.territoryRadius);\r\n            }\r\n            if (def.effectRadius) {\r\n                this.territoryGraphics.lineStyle(2, 0xffd700, 0.3);\r\n                this.territoryGraphics.strokeEllipse(iso.x, iso.y, def.effectRadius * 2, def.effectRadius);\r\n            }\r\n        });\r\n    }\r\n\r\n    public emitDustParticles(isoX: number, isoY: number, buildingWidth: number) {\r\n        // Smoke poof from 8 points around building - like building dropped from sky\r\n        const offset = buildingWidth * 0.45;\r\n        const diagOffset = offset * 0.7;\r\n        const particlesPerPoint = 5;\r\n\r\n        // 8 emission points: 4 cardinal + 4 diagonal corners\r\n        const emissionPoints = [\r\n            // Cardinal directions\r\n            { x: isoX - offset, y: isoY, angle: 180 },           // Left\r\n            { x: isoX + offset, y: isoY, angle: 0 },             // Right  \r\n            { x: isoX, y: isoY - offset * 0.5, angle: 270 },     // Top\r\n            { x: isoX, y: isoY + offset * 0.5, angle: 90 },      // Bottom\r\n            // Diagonal corners\r\n            { x: isoX - diagOffset, y: isoY - diagOffset * 0.5, angle: 225 }, // Top-left\r\n            { x: isoX + diagOffset, y: isoY - diagOffset * 0.5, angle: 315 }, // Top-right\r\n            { x: isoX - diagOffset, y: isoY + diagOffset * 0.5, angle: 135 }, // Bottom-left\r\n            { x: isoX + diagOffset, y: isoY + diagOffset * 0.5, angle: 45 },  // Bottom-right\r\n        ];\r\n\r\n        emissionPoints.forEach(point => {\r\n            const emitter = this.scene.add.particles(point.x, point.y, 'smoke', {\r\n                speed: { min: 40, max: 80 },\r\n                angle: { min: point.angle - 25, max: point.angle + 25 }, // Horizontal spread\r\n                scale: { start: 0.08, end: 0.18 },\r\n                alpha: { start: 0.65, end: 0 },\r\n                lifespan: 900,\r\n                gravityY: 0, // No initial gravity\r\n                accelerationY: -60, // Curves upward over time - billowing effect!\r\n                rotate: { min: -90, max: 90 },\r\n                emitting: false\r\n            });\r\n            emitter.setDepth(Number.MAX_VALUE - 10);\r\n            emitter.explode(particlesPerPoint);\r\n\r\n            this.scene.time.delayedCall(1100, () => emitter.destroy());\r\n        });\r\n    }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\LGSM228\\CivStrategy\\game\\systems\\CullingSystem.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":76,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":76,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2995,2998],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2995,2998],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":81,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":81,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3285,3288],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3285,3288],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":111,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":111,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4619,4622],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4619,4622],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":118,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":118,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4969,4972],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4969,4972],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":122,"column":108,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":122,"endColumn":111,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5454,5457],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5454,5457],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":122,"column":127,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":122,"endColumn":130,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5473,5476],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5473,5476],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":125,"column":106,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":125,"endColumn":109,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5687,5690],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5687,5690],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":125,"column":124,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":125,"endColumn":127,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5705,5708],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5705,5708],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\LGSM228\\CivStrategy\\game\\systems\\EconomySystem.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":246,"column":61,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":246,"endColumn":64,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12320,12323],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12320,12323],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":166,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":166,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7775,7778],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7775,7778],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":234,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":234,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11371,11374],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11371,11374],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\r\nimport Phaser from 'phaser';\r\nimport { MainScene } from '../MainScene';\r\nimport { BuildingType, BuildingDef, UnitState, UnitType, GameStats, ResourceRates } from '../../types';\r\nimport { EVENTS } from '../../constants';\r\n\r\ninterface GameUnit extends Phaser.GameObjects.Image {\r\n    unitType: UnitType;\r\n    state: UnitState;\r\n    jobBuilding?: Phaser.GameObjects.GameObject;\r\n    path?: Phaser.Math.Vector2[];\r\n    pathStep?: number;\r\n}\r\n\r\nexport class EconomySystem {\r\n    private scene: MainScene;\r\n    private lastRates: ResourceRates = { wood: 0, food: 0, gold: 0, foodConsumption: 0 };\r\n    private lastHappinessChange: number = 0;\r\n\r\n    constructor(scene: MainScene) {\r\n        this.scene = scene;\r\n    }\r\n\r\n    public tickPopulation() {\r\n        // Only manage Player population (Owner 0)\r\n        if (this.scene.population < this.scene.maxPopulation && this.scene.happiness > 50) {\r\n            const houses = this.scene.buildings.getChildren().filter((b) =>\r\n                b.getData('def').type === BuildingType.HOUSE && b.getData('owner') === 0\r\n            ) as Phaser.GameObjects.Rectangle[];\r\n\r\n            let spawnSource = null;\r\n            if (houses.length > 0) {\r\n                spawnSource = houses[Phaser.Math.Between(0, houses.length - 1)];\r\n            } else {\r\n                const townCenters = this.scene.buildings.getChildren().filter((b) =>\r\n                    b.getData('def').type === BuildingType.TOWN_CENTER && b.getData('owner') === 0\r\n                ) as Phaser.GameObjects.Rectangle[];\r\n                if (townCenters.length > 0) spawnSource = townCenters[0];\r\n            }\r\n\r\n            if (spawnSource) {\r\n                const offsetX = Phaser.Math.Between(-30, 30);\r\n                const offsetY = Phaser.Math.Between(-30, 30);\r\n                const spawnX = spawnSource.x + (offsetX >= 0 ? 50 : -50) + offsetX;\r\n                const spawnY = spawnSource.y + (offsetY >= 0 ? 50 : -50) + offsetY;\r\n\r\n                this.scene.entityFactory.spawnUnit(UnitType.VILLAGER, spawnX, spawnY, 0);\r\n                this.scene.events.emit('message', \"A new peasant has arrived.\");\r\n            }\r\n        }\r\n    }\r\n\r\n    public assignJobs() {\r\n        const vacantBuildings = this.scene.buildings.getChildren().filter((b) => {\r\n            const def = b.getData('def') as BuildingDef;\r\n            const assignedWorker = b.getData('assignedWorker');\r\n            return def.workerNeeds && !assignedWorker;\r\n        });\r\n\r\n        const idleVillagers = this.scene.units.getChildren().filter((u) => {\r\n            const unit = u as unknown as GameUnit;\r\n            return (unit.unitType === UnitType.VILLAGER) && (unit.state === UnitState.IDLE || unit.state === UnitState.MOVING_TO_RALLY);\r\n        }) as Phaser.GameObjects.GameObject[];\r\n\r\n        for (const building of vacantBuildings) {\r\n            if (idleVillagers.length === 0) break;\r\n\r\n            const b = building as Phaser.GameObjects.Image;\r\n            const buildingOwner = b.getData('owner');\r\n\r\n            let closestWorker: Phaser.GameObjects.GameObject | null = null;\r\n            let minDist = Number.MAX_VALUE;\r\n            let workerIndex = -1;\r\n\r\n            for (let i = 0; i < idleVillagers.length; i++) {\r\n                const u = idleVillagers[i] as Phaser.GameObjects.Image;\r\n\r\n                // STRICT OWNERSHIP CHECK: Only assign villagers to buildings of the same owner\r\n                if (u.getData('owner') !== buildingOwner) continue;\r\n\r\n                const dist = Phaser.Math.Distance.Between(b.x, b.y, u.x, u.y);\r\n                if (dist < minDist) {\r\n                    minDist = dist;\r\n                    closestWorker = u;\r\n                    workerIndex = i;\r\n                }\r\n            }\r\n\r\n            if (closestWorker) {\r\n                idleVillagers.splice(workerIndex, 1);\r\n                b.setData('assignedWorker', closestWorker);\r\n                (closestWorker as unknown as GameUnit).state = UnitState.MOVING_TO_WORK;\r\n                (closestWorker as unknown as GameUnit).jobBuilding = b;\r\n\r\n                const path = this.scene.pathfinder.findPath(new Phaser.Math.Vector2((closestWorker as unknown as GameUnit).x, (closestWorker as unknown as GameUnit).y), new Phaser.Math.Vector2(b.x, b.y));\r\n                if (path) {\r\n                    (closestWorker as unknown as GameUnit).path = path;\r\n                    (closestWorker as unknown as GameUnit).pathStep = 0;\r\n                }\r\n            }\r\n        }\r\n\r\n        // Re-filter idle villagers to those who are still truly idle and job-less\r\n        const remainingIdle = this.scene.units.getChildren().filter((u) => {\r\n            const unit = u as unknown as GameUnit;\r\n            return unit.unitType === UnitType.VILLAGER && unit.state === UnitState.IDLE && !unit.jobBuilding;\r\n        });\r\n\r\n        if (remainingIdle.length > 0) {\r\n            const allBonfires = this.scene.buildings.getChildren().filter((b) => b.getData('def').type === BuildingType.BONFIRE) as Phaser.GameObjects.Rectangle[];\r\n\r\n            if (allBonfires.length > 0) {\r\n                remainingIdle.forEach((u) => {\r\n                    const owner = u.getData('owner');\r\n                    // Filter bonfires by OWNER\r\n                    const myBonfires = allBonfires.filter((b) => b.getData('owner') === owner);\r\n\r\n                    if (myBonfires.length > 0) {\r\n                        let closestBonfire = myBonfires[0];\r\n                        let minDistance = Number.MAX_VALUE;\r\n                        for (const bonfire of myBonfires) {\r\n                            const d = Phaser.Math.Distance.Between((u as Phaser.GameObjects.Image).x, (u as Phaser.GameObjects.Image).y, bonfire.x, bonfire.y);\r\n                            if (d < minDistance) {\r\n                                minDistance = d;\r\n                                closestBonfire = bonfire;\r\n                            }\r\n                        }\r\n                        const rallyPoint = closestBonfire;\r\n                        // Only move if far away\r\n                        if (minDistance > 100) {\r\n                            (u as unknown as GameUnit).state = UnitState.MOVING_TO_RALLY;\r\n                            const angle = Math.random() * Math.PI * 2;\r\n                            const r = Math.random() * 60 + 40;\r\n                            const destX = rallyPoint.x + Math.cos(angle) * r;\r\n                            const destY = rallyPoint.y + Math.sin(angle) * r;\r\n                            const path = this.scene.pathfinder.findPath(new Phaser.Math.Vector2((u as Phaser.GameObjects.Image).x, (u as Phaser.GameObjects.Image).y), new Phaser.Math.Vector2(destX, destY));\r\n                            if (path) {\r\n                                (u as unknown as GameUnit).path = path;\r\n                                (u as unknown as GameUnit).pathStep = 0;\r\n                            }\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n        }\r\n    }\r\n\r\n    public tickEconomy() {\r\n        const isLowHappiness = this.scene.happiness < 50;\r\n        const efficiency = isLowHappiness ? 0.5 : 1.0;\r\n        const taxGoldPerPop = this.scene.taxRate;\r\n\r\n        let foodGen = 0;\r\n        let woodGen = 0;\r\n\r\n        // Base Commerce for Player\r\n        let goldGen = Math.floor((this.scene.population * (0.5 + taxGoldPerPop)) * efficiency);\r\n\r\n        const harvestedTrees = new Set<Phaser.GameObjects.GameObject>();\r\n\r\n        this.scene.buildings.getChildren().forEach((b) => {\r\n            // STRICT OWNERSHIP CHECK: Only process PLAYER buildings for player economy\r\n            if (b.getData('owner') !== 0) return;\r\n\r\n            const def = b.getData('def') as BuildingDef;\r\n            const visual = (b as any).visual as Phaser.GameObjects.Container; // eslint-disable-line @typescript-eslint/no-explicit-any\r\n            const vacantIcon = visual.getData('vacantIcon') as Phaser.GameObjects.Text;\r\n            const noResIcon = visual.getData('noResIcon') as Phaser.GameObjects.Text;\r\n\r\n            let isWorking = true;\r\n            let productionAmount = 0;\r\n            let productionType = '';\r\n\r\n            if (def.workerNeeds) {\r\n                const worker = b.getData('assignedWorker');\r\n                if (worker && worker.state === UnitState.WORKING) {\r\n                    if (vacantIcon) vacantIcon.visible = false;\r\n                } else {\r\n                    isWorking = false;\r\n                    if (vacantIcon) vacantIcon.visible = true;\r\n                }\r\n            }\r\n\r\n            if (def.type === BuildingType.TOWN_CENTER) {\r\n                goldGen += Math.floor(2 * efficiency);\r\n                isWorking = true;\r\n            }\r\n\r\n            if (isWorking) {\r\n                if (def.type === BuildingType.FARM) {\r\n                    let gain = 5;\r\n                    const isFertile = this.scene.fertileZones.some(zone => zone.contains((b as Phaser.GameObjects.Image).x, (b as Phaser.GameObjects.Image).y));\r\n                    if (isFertile) gain = Math.floor(gain * 1.5);\r\n                    gain = Math.floor(gain * efficiency);\r\n                    foodGen += gain;\r\n                    productionAmount = gain;\r\n                    productionType = 'Food';\r\n                }\r\n\r\n                if (def.type === BuildingType.LUMBER_CAMP && def.effectRadius) {\r\n                    let treesNearby = 0;\r\n                    // Optimize: Use Spatial Partitioning\r\n                    const candidates = this.scene.treeSpatialHash.query((b as Phaser.GameObjects.Image).x, (b as Phaser.GameObjects.Image).y, def.effectRadius);\r\n\r\n                    for (const t of candidates) {\r\n                        // Cast t to Image to access x,y\r\n                        const tree = t as Phaser.GameObjects.Image;\r\n                        if (Phaser.Math.Distance.Between((b as Phaser.GameObjects.Image).x, (b as Phaser.GameObjects.Image).y, tree.x, tree.y) < def.effectRadius) {\r\n                            const isChopped = tree.getData('isChopped');\r\n                            if (!isChopped && !harvestedTrees.has(tree)) {\r\n                                treesNearby++;\r\n                                harvestedTrees.add(tree);\r\n                                if (Math.random() < 0.1) {\r\n                                    this.scene.entityFactory.updateTreeVisual(tree, true);\r\n                                    // if (this.scene.minimapSystem) this.scene.minimapSystem.refreshStaticLayer();\r\n                                    this.scene.feedbackSystem.showFloatingText(tree.x, tree.y, \"Chopped!\", \"#a0522d\");\r\n                                }\r\n\r\n                            }\r\n                        }\r\n                    }\r\n                    if (noResIcon) noResIcon.visible = (treesNearby === 0);\r\n                    let gain = Math.min(treesNearby * 2, 12);\r\n                    gain = Math.floor(gain * efficiency);\r\n                    woodGen += gain;\r\n                    if (gain > 0) {\r\n                        productionAmount = gain;\r\n                        productionType = 'Wood';\r\n                    }\r\n                }\r\n\r\n                if (def.type === BuildingType.HUNTERS_LODGE && def.effectRadius) {\r\n                    const animals = this.scene.units.getChildren().filter((u) => {\r\n                        return (u as any).unitType === UnitType.ANIMAL && Phaser.Math.Distance.Between((b as Phaser.GameObjects.Image).x, (b as Phaser.GameObjects.Image).y, (u as Phaser.GameObjects.Image).x, (u as Phaser.GameObjects.Image).y) < def.effectRadius!; // eslint-disable-line @typescript-eslint/no-explicit-any\r\n                    });\r\n                    const animalsNearby = animals.length;\r\n                    if (noResIcon) noResIcon.visible = (animalsNearby === 0);\r\n                    if (animalsNearby > 0) {\r\n                        let gain = 20;\r\n                        gain = Math.floor(gain * efficiency);\r\n                        foodGen += gain;\r\n                        productionAmount = gain;\r\n                        productionType = 'Food';\r\n                        if (Math.random() < 0.20) {\r\n                            const victim = animals[Phaser.Math.Between(0, animalsNearby - 1)];\r\n                            const victimVisual = (victim as any).visual;\r\n                            if (victimVisual) victimVisual.destroy();\r\n                            victim.destroy();\r\n                            this.scene.feedbackSystem.showFloatingText(b.x, b.y - 30, \"Depleted!\", \"#ef4444\");\r\n                        }\r\n\r\n                    }\r\n                }\r\n            }\r\n            if (productionAmount > 0) {\r\n                this.scene.feedbackSystem.showFloatingResource((b as Phaser.GameObjects.Image).x, (b as Phaser.GameObjects.Image).y, productionAmount, productionType);\r\n            }\r\n\r\n        });\r\n\r\n        if (goldGen > 0) {\r\n            const tcs = this.scene.buildings.getChildren().filter((b) =>\r\n                b.getData('def').type === BuildingType.TOWN_CENTER && b.getData('owner') === 0\r\n            ) as Phaser.GameObjects.Rectangle[];\r\n            if (tcs.length > 0) {\r\n                this.scene.feedbackSystem.showFloatingResource(tcs[0].x, tcs[0].y, goldGen, 'Gold');\r\n            }\r\n\r\n        }\r\n\r\n        const foodConsumed = this.scene.population * 1;\r\n        this.lastRates = { wood: woodGen, food: foodGen, gold: goldGen, foodConsumption: foodConsumed };\r\n        this.scene.resources.food += foodGen;\r\n        this.scene.resources.wood += woodGen;\r\n        this.scene.resources.gold += goldGen;\r\n        this.scene.resources.food -= foodConsumed;\r\n        if (this.scene.resources.food < 0) this.scene.resources.food = 0;\r\n\r\n        let happinessChange = 0;\r\n        const isStarving = this.scene.resources.food === 0 && foodConsumed > 0;\r\n        if (isStarving) { happinessChange -= 5; } else { happinessChange += 1; }\r\n        if (this.scene.population > this.scene.maxPopulation) { happinessChange -= 2; }\r\n        const taxImpact = [1, 0, -1, -3, -6, -10];\r\n        happinessChange += (taxImpact[this.scene.taxRate] || 0);\r\n\r\n        // Count ONLY player parks\r\n        const parks = this.scene.buildings.getChildren().filter((b) =>\r\n            b.getData('def').type === BuildingType.SMALL_PARK && b.getData('owner') === 0\r\n        );\r\n        happinessChange += parks.length;\r\n\r\n        this.scene.happiness += happinessChange;\r\n        this.scene.happiness = Phaser.Math.Clamp(this.scene.happiness, 0, 100);\r\n        this.lastHappinessChange = happinessChange;\r\n        this.updateStats();\r\n    }\r\n\r\n    public updateStats() {\r\n        const remainingTreaty = Math.max(0, this.scene.treatyLength - this.scene.gameTime);\r\n\r\n        const stats: GameStats = {\r\n            population: this.scene.population,\r\n            maxPopulation: this.scene.maxPopulation,\r\n            happiness: this.scene.happiness,\r\n            happinessChange: this.lastHappinessChange,\r\n            resources: { ...this.scene.resources },\r\n            rates: this.lastRates,\r\n            taxRate: this.scene.taxRate,\r\n            mapMode: this.scene.mapMode,\r\n            peacefulMode: this.scene.peacefulMode,\r\n            treatyTimeRemaining: remainingTreaty\r\n        };\r\n        this.scene.game.events.emit(EVENTS.UPDATE_STATS, stats);\r\n    }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\LGSM228\\CivStrategy\\game\\systems\\EnemyAISystem.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":144,"column":143,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":144,"endColumn":146,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4971,4974],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4971,4974],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\r\nimport Phaser from 'phaser';\r\nimport { MainScene } from '../MainScene';\r\nimport { BuildingType, UnitType, Resources, UnitState, MapMode, BuildingDef } from '../../types';\r\nimport { BUILDINGS } from '../../constants';\r\n\r\ninterface BlueprintItem {\r\n    type: BuildingType;\r\n    x: number;\r\n    y: number;\r\n}\r\n\r\nconst AI_BLUEPRINT: BlueprintItem[] = [\r\n    { type: BuildingType.TOWN_CENTER, x: 0, y: 0 },\r\n    { type: BuildingType.HOUSE, x: -80, y: 0 },\r\n    { type: BuildingType.HOUSE, x: 80, y: 0 },\r\n    { type: BuildingType.HOUSE, x: 0, y: -80 },\r\n    { type: BuildingType.HOUSE, x: 0, y: 80 },\r\n    { type: BuildingType.LUMBER_CAMP, x: -150, y: -150 },\r\n    { type: BuildingType.LUMBER_CAMP, x: 150, y: 150 },\r\n    { type: BuildingType.FARM, x: 150, y: -150 },\r\n    { type: BuildingType.FARM, x: -150, y: 150 },\r\n    { type: BuildingType.BARRACKS, x: 100, y: 100 },\r\n    { type: BuildingType.BARRACKS, x: -100, y: -100 },\r\n    { type: BuildingType.BONFIRE, x: 250, y: 0 },\r\n    { type: BuildingType.BONFIRE, x: -250, y: 0 },\r\n    { type: BuildingType.BONFIRE, x: 0, y: 250 },\r\n    { type: BuildingType.BONFIRE, x: 0, y: -250 },\r\n];\r\n\r\nexport class EnemyAISystem {\r\n    private scene: MainScene;\r\n\r\n    // AI State\r\n    private resources: Resources = { wood: 500, food: 500, gold: 500 };\r\n    private baseX: number = 200;\r\n    private baseY: number = 200;\r\n    private buildings: (Phaser.GameObjects.GameObject | null)[] = new Array(AI_BLUEPRINT.length).fill(null);\r\n\r\n    // Personality\r\n    private aggressionThreshold = 8;\r\n    private unitPreference = UnitType.SOLDIER;\r\n    private attackTarget: Phaser.GameObjects.GameObject | null = null; // Changed to GameObject for Entity targeting\r\n\r\n    private lastTick: number = 0;\r\n    private buildIndex: number = 0;\r\n\r\n    constructor(scene: MainScene) {\r\n        this.scene = scene;\r\n\r\n        if (this.scene.mapMode === MapMode.INFINITE) {\r\n            // Spawn far away in infinite mode\r\n            this.baseX = 4000;\r\n            this.baseY = 4000;\r\n        } else {\r\n            // Fixed mode: Player is at center (e.g. 1024,1024), spawn enemy at top-left\r\n            this.baseX = this.scene.mapWidth * 0.15;\r\n            this.baseY = this.scene.mapHeight * 0.15;\r\n        }\r\n    }\r\n\r\n    public update(time: number, _delta: number) {\r\n        if (this.scene.aiDisabled) return;\r\n\r\n        // Tick AI logic every 1s\r\n        if (time - this.lastTick > 1000) {\r\n            this.tickAI();\r\n            this.lastTick = time;\r\n        }\r\n    }\r\n\r\n    private tickAI() {\r\n        this.tickEconomy();\r\n        this.tickBuild();\r\n        this.tickRecruit();\r\n        this.tickAttack();\r\n    }\r\n\r\n    private tickEconomy() {\r\n        this.resources.wood += 20;\r\n        this.resources.food += 20;\r\n        this.resources.gold += 10;\r\n    }\r\n\r\n    private tickBuild() {\r\n        for (let i = 0; i <= Math.min(this.buildIndex, AI_BLUEPRINT.length - 1); i++) {\r\n            const existing = this.buildings[i];\r\n            if (existing && !existing.scene) {\r\n                this.buildings[i] = null;\r\n            }\r\n\r\n            if (!this.buildings[i]) {\r\n                this.tryConstruct(i);\r\n                if (i < this.buildIndex) return;\r\n            }\r\n        }\r\n\r\n        if (this.buildings[this.buildIndex] && this.buildIndex < AI_BLUEPRINT.length - 1) {\r\n            this.buildIndex++;\r\n        }\r\n    }\r\n\r\n    private tryConstruct(index: number) {\r\n        const item = AI_BLUEPRINT[index];\r\n        const def = BUILDINGS[item.type];\r\n\r\n        if (this.canAfford(def.cost)) {\r\n            const bx = this.baseX + item.x;\r\n            const by = this.baseY + item.y;\r\n\r\n            this.resources.wood -= def.cost.wood;\r\n            this.resources.food -= def.cost.food;\r\n            this.resources.gold -= def.cost.gold;\r\n\r\n            const b = this.scene.entityFactory.spawnBuilding(item.type, bx, by, 1);\r\n            this.buildings[index] = b;\r\n        }\r\n    }\r\n\r\n    private tickRecruit() {\r\n        const hasBarracks = this.buildings.some(b => b && b.scene && (b.getData('def') as BuildingDef).type === BuildingType.BARRACKS);\r\n        if (!hasBarracks) return;\r\n\r\n        if (this.resources.food >= 100 && this.resources.gold >= 50) {\r\n            this.resources.food -= 100;\r\n            this.resources.gold -= 50;\r\n\r\n            const spawnX = this.baseX + Phaser.Math.Between(-50, 50);\r\n            const spawnY = this.baseY + Phaser.Math.Between(-50, 50);\r\n\r\n            this.scene.entityFactory.spawnUnit(this.unitPreference, spawnX, spawnY, 1);\r\n        }\r\n    }\r\n\r\n    private tickAttack() {\r\n        // DIPLOMACY CHECKS\r\n        // Strictly check boolean true\r\n        if (this.scene.peacefulMode === true) return;\r\n\r\n        // Check treaty timer\r\n        if (this.scene.gameTime < this.scene.treatyLength) return;\r\n\r\n        // Get all AI units\r\n        const mySoldiers = this.scene.units.getChildren().filter((u) => u.getData('owner') === 1 && (u.getData('def') && (u.getData('def') as any).isMilitary)) as Phaser.GameObjects.GameObject[];\r\n\r\n        const readyToAttack = mySoldiers.length >= this.aggressionThreshold;\r\n\r\n        if (readyToAttack) {\r\n            // Find Target (Player Town Center or any building)\r\n            if (!this.attackTarget || !this.attackTarget.scene) {\r\n                const playerTC = this.scene.buildings.getChildren().find((b) => {\r\n                    return b.getData('owner') === 0 && b.getData('def').type === BuildingType.TOWN_CENTER;\r\n                });\r\n\r\n                if (playerTC) {\r\n                    this.attackTarget = playerTC;\r\n\r\n                    const leader = mySoldiers[0] as Phaser.GameObjects.Image;\r\n                    this.scene.feedbackSystem.showFloatingText(leader.x, leader.y, \"The Boar: CRUSH THEM!\", \"#ef4444\");\r\n                } else {\r\n                    this.attackTarget = this.findAttackTarget();\r\n                }\r\n            }\r\n\r\n            if (this.attackTarget && this.attackTarget.scene) {\r\n                // Command all idle units to attack\r\n                const idleTroops = mySoldiers.filter((u) => (u as unknown as { state: UnitState }).state === UnitState.IDLE);\r\n                if (idleTroops.length > 0) {\r\n                    this.scene.unitSystem.commandAttack(idleTroops, this.attackTarget);\r\n                }\r\n            }\r\n        } else {\r\n            if (mySoldiers.length < 2) {\r\n                this.attackTarget = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    private findAttackTarget(): Phaser.GameObjects.GameObject | null {\r\n        const enemyUnits = this.scene.units.getChildren().filter((u) => u.getData('owner') === 0);\r\n        if (enemyUnits.length > 0) {\r\n            return enemyUnits[Phaser.Math.Between(0, enemyUnits.length - 1)];\r\n        }\r\n\r\n        const enemyBuildings = this.scene.buildings.getChildren().filter((b) => b.getData('owner') === 0);\r\n        if (enemyBuildings.length > 0) {\r\n            return enemyBuildings[Phaser.Math.Between(0, enemyBuildings.length - 1)];\r\n        }\r\n        return null;\r\n    }\r\n\r\n    private canAfford(cost: { wood: number, food: number, gold: number }): boolean {\r\n        return this.resources.wood >= cost.wood &&\r\n            this.resources.food >= cost.food &&\r\n            this.resources.gold >= cost.gold;\r\n    }\r\n\r\n    public getDebugInfo(): string {\r\n        const armySize = this.scene.units.getChildren().filter((u) => u.getData('owner') === 1).length;\r\n        const target = this.attackTarget ? (this.attackTarget.getData('def') ? (this.attackTarget.getData('def') as BuildingDef).type : 'Unit') : 'None';\r\n        return `Res: ${this.resources.wood}/${this.resources.food} | Army: ${armySize} | Target: ${target} | State: ${this.buildIndex}/${AI_BLUEPRINT.length}`;\r\n    }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\LGSM228\\CivStrategy\\game\\systems\\EntityFactory.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":119,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":119,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5755,5758],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5755,5758],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":180,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":180,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8780,8783],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8780,8783],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":192,"column":59,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":192,"endColumn":62,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9505,9508],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9505,9508],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":192,"column":78,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":192,"endColumn":81,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9524,9527],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9524,9527],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":196,"column":46,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":196,"endColumn":49,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9780,9783],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9780,9783],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":196,"column":65,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":196,"endColumn":68,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9799,9802],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9799,9802],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":220,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":220,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10829,10832],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10829,10832],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'def' is defined but never used. Allowed unused args must match /^_/u.","line":267,"column":67,"nodeType":null,"messageId":"unusedVar","endLine":267,"endColumn":70}],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":83,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":83,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3827,3830],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3827,3830],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":90,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":90,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4263,4266],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4263,4266],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":91,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":91,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4384,4387],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4384,4387],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":107,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":107,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5050,5053],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5050,5053],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":147,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":147,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6873,6876],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6873,6876],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":148,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":148,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6971,6974],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6971,6974],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":154,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":154,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7287,7290],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7287,7290],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":155,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":155,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7392,7395],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7392,7395],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":156,"column":22,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":156,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7516,7519],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7516,7519],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":162,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":162,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7873,7876],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7873,7876],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":8,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\r\nimport Phaser from 'phaser';\r\nimport { MainScene } from '../MainScene';\r\nimport { BuildingType, UnitType, UnitState, BuildingDef, FactionType } from '../../types';\r\nimport { BUILDINGS, UNIT_STATS } from '../../constants';\r\nimport { toIso } from '../utils/iso';\r\n\r\nexport class EntityFactory {\r\n    private scene: MainScene;\r\n\r\n    constructor(scene: MainScene) {\r\n        this.scene = scene;\r\n    }\r\n\r\n    public spawnBuilding(type: BuildingType, x: number, y: number, owner: number = 0): Phaser.GameObjects.GameObject {\r\n        const def = BUILDINGS[type];\r\n        const b = this.scene.add.rectangle(x, y, def.width, def.height, 0x000000, 0);\r\n        this.scene.physics.add.existing(b, true);\r\n        b.setData('def', def);\r\n        b.setData('owner', owner);\r\n        b.setData('hp', def.maxHp);\r\n        b.setData('maxHp', def.maxHp);\r\n        this.scene.buildings.add(b);\r\n\r\n        this.scene.pathfinder.markGrid(x, y, def.width, def.height, true);\r\n\r\n        const visual = this.scene.add.container(0, 0);\r\n        const gfx = this.scene.add.graphics();\r\n        const baseColor = owner === 1 ? 0x3f3f46 : def.color; // Keep dark base for enemy buildings for contrast, or maybe subtle tint? Let's keep it but make banner colorful.\r\n        // ACTUALLY plan says \"Update the enemy banner creation to use this.scene.getFactionColor(owner)\".\r\n        // And \"Update spawnUnit to use this.scene.getFactionColor(owner)\".\r\n        // Let's stick to the plan.\r\n\r\n        let spriteUsed = false;\r\n\r\n        const setupSprite = (key: string, scaleMultiplier: number = 2.2, originY: number = 0.75) => {\r\n            if (!this.scene.textures.exists(key)) return false;\r\n            const sprite = this.scene.add.image(0, 0, key);\r\n            sprite.setOrigin(0.5, originY);\r\n            const targetWidth = def.width * scaleMultiplier;\r\n            const scale = targetWidth / sprite.width;\r\n            sprite.setScale(scale);\r\n            visual.add(sprite);\r\n            return true;\r\n        };\r\n\r\n        if (type === BuildingType.FARM) { if (setupSprite('field', 2.0, 0.5)) spriteUsed = true; }\r\n        else if (type === BuildingType.HOUSE) { if (setupSprite('house', 2.5, 0.85)) spriteUsed = true; }\r\n        else if (type === BuildingType.HUNTERS_LODGE) { if (setupSprite('lodge', 2.5, 0.75)) spriteUsed = true; }\r\n\r\n        if (!spriteUsed && owner === 0 && this.scene.faction === FactionType.ROMANS) {\r\n            if (type === BuildingType.TOWN_CENTER) { if (setupSprite('townhall', 1.5, 0.75)) spriteUsed = true; }\r\n            else if (type === BuildingType.LUMBER_CAMP) { if (setupSprite('lumber', 2.6, 0.75)) spriteUsed = true; }\r\n        }\r\n\r\n        if (!spriteUsed) {\r\n            if (type === BuildingType.BONFIRE) {\r\n                this.drawBonfire(gfx);\r\n                this.scene.tweens.add({ targets: gfx, scaleX: 1.05, scaleY: 1.05, alpha: 0.9, yoyo: true, repeat: -1, duration: 150 });\r\n            } else if (type === BuildingType.SMALL_PARK) {\r\n                this.drawPark(gfx);\r\n            } else {\r\n                this.drawIsoBuilding(gfx, def, baseColor);\r\n            }\r\n        }\r\n\r\n        if (owner === 1) {\r\n            const banner = this.scene.add.rectangle(0, -40, 16, 8, this.scene.getFactionColor(owner));\r\n            visual.add(banner);\r\n        }\r\n\r\n        if (!spriteUsed || type === BuildingType.BONFIRE || type === BuildingType.SMALL_PARK) {\r\n            const text = this.scene.add.text(0, -def.height * 0.5 - 10, def.name[0], { fontSize: '14px', color: '#ffffff' }).setOrigin(0.5);\r\n            visual.add([gfx, text]);\r\n        } else {\r\n            visual.add(gfx);\r\n        }\r\n\r\n        const hpBar = this.createHealthBar(visual, def.width, -def.height * 0.8 - 35);\r\n        visual.setData('hpBar', hpBar);\r\n\r\n        this.scene.add.existing(visual);\r\n        (b as any).visual = visual; // eslint-disable-line @typescript-eslint/no-explicit-any\r\n        const iso = toIso(x, y);\r\n        visual.setPosition(iso.x, iso.y).setDepth(iso.y);\r\n        visual.setInteractive(new Phaser.Geom.Rectangle(-def.width / 2, -def.height, def.width, def.height), Phaser.Geom.Rectangle.Contains);\r\n        visual.setData('building', b);\r\n\r\n        // Building selection method with pulsing glow effect\r\n        (b as any).setSelected = (selected: boolean) => { // eslint-disable-line @typescript-eslint/no-explicit-any\r\n            (b as any).isSelected = selected; // eslint-disable-line @typescript-eslint/no-explicit-any\r\n            const hpBar = visual.getData('hpBar') as Phaser.GameObjects.Container;\r\n            if (hpBar) hpBar.setVisible(selected || b.getData('hp') < b.getData('maxHp'));\r\n\r\n            if (selected) {\r\n                this.startGlowEffect(visual, def);\r\n            } else {\r\n                this.stopGlowEffect(visual);\r\n            }\r\n        };\r\n\r\n        if (owner === 0) {\r\n            if (def.populationBonus) this.scene.maxPopulation += def.populationBonus;\r\n            if (def.happinessBonus) this.scene.happiness += def.happinessBonus;\r\n        }\r\n\r\n        (b as any).takeDamage = (amount: number) => this.handleDamage(b, amount, false); // eslint-disable-line @typescript-eslint/no-explicit-any\r\n        return b;\r\n    }\r\n\r\n    public spawnUnit(type: UnitType, x: number, y: number, owner: number = 0) {\r\n        const stats = UNIT_STATS[type];\r\n        const radius = 8;\r\n        const unit = this.scene.add.circle(x, y, radius, 0x000000, 0);\r\n        this.scene.physics.add.existing(unit);\r\n        const body = unit.body as Phaser.Physics.Arcade.Body;\r\n        body.setCircle(radius);\r\n        unit.setData({ owner, unitType: type, hp: stats.maxHp, maxHp: stats.maxHp, attack: stats.attack, range: stats.range, attackSpeed: stats.attackSpeed });\r\n        (unit as any).lastAttackTime = 0;\r\n        this.scene.units.add(unit);\r\n\r\n        // Increment population for player-owned units (but not animals)\r\n        if (owner === 0 && type !== UnitType.ANIMAL) {\r\n            this.scene.population++;\r\n        }\r\n\r\n        const visual = this.scene.add.container(0, 0);\r\n        const gfx = this.scene.add.graphics();\r\n        const primaryColor = this.scene.getFactionColor(owner);\r\n\r\n        if (type === UnitType.VILLAGER) {\r\n            gfx.fillStyle(primaryColor, 1).fillEllipse(0, 0, 10, 6);\r\n            visual.add([gfx, this.scene.add.rectangle(0, -6, 4, 8, owner === 1 ? 0x18181b : 0x7CB342), this.scene.add.circle(0, -11, 2.5, 0xffcccc)]);\r\n        } else if (type === UnitType.ANIMAL) {\r\n            gfx.fillStyle(0x795548, 1).fillEllipse(0, 0, 12, 7);\r\n            visual.add(gfx);\r\n            visual.setScale(0.8);\r\n        } else {\r\n            visual.setVisible(false);\r\n        }\r\n\r\n        if (stats.squadSize === 1) {\r\n            visual.setData('hpBar', this.createHealthBar(visual, 24, -20));\r\n        }\r\n\r\n        this.scene.add.existing(visual);\r\n        (unit as any).visual = visual; // eslint-disable-line @typescript-eslint/no-explicit-any\r\n        (unit as any).unitType = type; // eslint-disable-line @typescript-eslint/no-explicit-any\r\n\r\n        // CRITICAL FIX: Make unit visual click-able for selection/targeting\r\n        visual.setInteractive(new Phaser.Geom.Circle(0, -10, 15), Phaser.Geom.Circle.Contains);\r\n        visual.setData('unit', unit);\r\n\r\n        (unit as any).state = UnitState.IDLE; // eslint-disable-line @typescript-eslint/no-explicit-any\r\n        (unit as any).setSelected = (selected: boolean) => { // eslint-disable-line @typescript-eslint/no-explicit-any\r\n            (unit as any).isSelected = selected; // eslint-disable-line @typescript-eslint/no-explicit-any\r\n            const hpBar = visual.getData('hpBar');\r\n            if (hpBar) hpBar.setVisible(selected || unit.getData('hp') < unit.getData('maxHp'));\r\n        };\r\n\r\n        if (stats.squadSize > 1) this.scene.squadSystem.createSquad(unit, type, owner);\r\n        (unit as any).takeDamage = (amount: number) => this.handleDamage(unit, amount, true); // eslint-disable-line @typescript-eslint/no-explicit-any\r\n        return unit;\r\n    }\r\n\r\n    private createHealthBar(visual: Phaser.GameObjects.Container, width: number, y: number): Phaser.GameObjects.Container {\r\n        const bar = this.scene.add.container(0, y);\r\n        const fg = this.scene.add.rectangle(-width / 2, 0, width, 2, 0x22c55e).setOrigin(0, 0.5).setName('barFill');\r\n        bar.add([this.scene.add.rectangle(0, 0, width, 4, 0x000000), fg]);\r\n        bar.setVisible(false);\r\n        visual.add(bar);\r\n        return bar;\r\n    }\r\n\r\n    private handleDamage(entity: Phaser.GameObjects.GameObject, amount: number, isUnit: boolean) {\r\n        let hp = entity.getData('hp');\r\n        const maxHp = entity.getData('maxHp');\r\n        hp -= amount;\r\n        entity.setData('hp', hp);\r\n        const visual = (entity as any).visual as Phaser.GameObjects.Container;\r\n        if (visual && visual.getData('hpBar')) {\r\n            const hpBar = visual.getData('hpBar') as Phaser.GameObjects.Container;\r\n            hpBar.setVisible(true);\r\n            const fill = hpBar.getByName('barFill') as Phaser.GameObjects.Rectangle;\r\n            fill.scaleX = Math.max(0, hp / maxHp);\r\n            fill.fillColor = fill.scaleX < 0.3 ? 0xef4444 : 0x22c55e;\r\n        }\r\n        if (hp <= 0) {\r\n            if (isUnit) { this.scene.squadSystem.destroySquad(entity); if (entity.getData('owner') === 0) this.scene.population--; }\r\n            else {\r\n                const def = entity.getData('def');\r\n                this.scene.pathfinder.markGrid((entity as any).x, (entity as any).y, def.width, def.height, false);\r\n                if (entity.getData('owner') === 0 && def.populationBonus) this.scene.maxPopulation -= def.populationBonus;\r\n\r\n                // Trigger explosion effect\r\n                const iso = toIso((entity as any).x, (entity as any).y);\r\n                this.scene.buildingManager.emitExplosionParticles(iso.x, iso.y, def.width);\r\n            }\r\n            if (visual) visual.destroy();\r\n            entity.destroy();\r\n        }\r\n    }\r\n\r\n    public spawnTree(x: number, y: number) {\r\n        // Optimization: Use single Image instead of Container + 2 Images\r\n        // VIRTUALIZATON: Do NOT create visual here. Store data for pool.\r\n        const treeBase = this.scene.add.circle(x, y, 6, 0x000000, 0);\r\n        treeBase.setVisible(false); // Invisible, logic only\r\n        this.scene.physics.add.existing(treeBase, true);\r\n        this.scene.trees.add(treeBase);\r\n        this.scene.treeSpatialHash.insert(treeBase);\r\n\r\n        // Store visual properties for later hydration\r\n        treeBase.setData('visualScale', Phaser.Math.FloatBetween(0.8, 1.1) * 0.075);\r\n        treeBase.setData('visualTexture', 'tree');\r\n        treeBase.setData('visualOriginY', 0.95);\r\n        treeBase.setData('isChopped', false);\r\n    }\r\n\r\n    public updateTreeVisual(tree: any, isChopped: boolean) {\r\n        tree.setData('isChopped', isChopped);\r\n\r\n        // Update data\r\n        if (isChopped) {\r\n            tree.setData('visualTexture', 'stump');\r\n            tree.setData('visualScale', 0.075);\r\n            tree.setData('visualOriginY', 0.5);\r\n        } else {\r\n            tree.setData('visualTexture', 'tree');\r\n            // Keep original random scale? simplified for now\r\n            tree.setData('visualOriginY', 0.95);\r\n        }\r\n\r\n        // If currently visible (has visual), update it immediately\r\n        const visual = tree.visual as Phaser.GameObjects.Image;\r\n        if (visual) {\r\n            visual.setTexture(tree.getData('visualTexture'));\r\n            visual.setScale(tree.getData('visualScale'));\r\n            visual.setOrigin(0.5, tree.getData('visualOriginY'));\r\n        }\r\n    }\r\n\r\n    public drawIsoBuilding(gfx: Phaser.GameObjects.Graphics, def: BuildingDef, color: number, alpha = 1) {\r\n        const w = def.width, h = def.height, height = Math.min(w, h) * 0.45;\r\n        const corners = [{ x: -w / 2, y: -h / 2 }, { x: w / 2, y: -h / 2 }, { x: w / 2, y: h / 2 }, { x: -w / 2, y: h / 2 }];\r\n        const isoCorners = corners.map(c => toIso(c.x, c.y));\r\n        gfx.fillStyle(color, alpha).beginPath();\r\n        gfx.moveTo(isoCorners[0].x, isoCorners[0].y - height).lineTo(isoCorners[1].x, isoCorners[1].y - height)\r\n            .lineTo(isoCorners[2].x, isoCorners[2].y - height).lineTo(isoCorners[3].x, isoCorners[3].y - height).closePath().fillPath();\r\n        gfx.fillStyle(Phaser.Display.Color.IntegerToColor(color).darken(20).color, alpha).beginPath()\r\n            .moveTo(isoCorners[2].x, isoCorners[2].y - height).lineTo(isoCorners[1].x, isoCorners[1].y - height)\r\n            .lineTo(isoCorners[1].x, isoCorners[1].y).lineTo(isoCorners[2].x, isoCorners[2].y).closePath().fillPath();\r\n    }\r\n\r\n    private drawBonfire(gfx: Phaser.GameObjects.Graphics) {\r\n        gfx.fillStyle(0x78716c).fillEllipse(0, 0, 24, 12);\r\n        gfx.fillStyle(0xf97316, 0.8).beginPath().moveTo(-6, -6).lineTo(0, -20).lineTo(6, -6).closePath().fillPath();\r\n    }\r\n\r\n    private drawPark(gfx: Phaser.GameObjects.Graphics) {\r\n        gfx.fillStyle(0x86efac).beginPath();\r\n        const pts = [toIso(-14, -14), toIso(14, -14), toIso(14, 14), toIso(-14, 14)];\r\n        gfx.moveTo(pts[0].x, pts[0].y).lineTo(pts[1].x, pts[1].y).lineTo(pts[2].x, pts[2].y).lineTo(pts[3].x, pts[3].y).closePath().fillPath();\r\n        gfx.fillStyle(0x15803d).fillCircle(0, -4, 6);\r\n    }\r\n\r\n    private startGlowEffect(visual: Phaser.GameObjects.Container, def: BuildingDef) {\r\n        // Remove any existing glow\r\n        this.stopGlowEffect(visual);\r\n\r\n        // Find all sprites/images in the container and create additive overlays\r\n        const glowOverlays: Phaser.GameObjects.Image[] = [];\r\n        visual.each((child: Phaser.GameObjects.GameObject) => {\r\n            if (child instanceof Phaser.GameObjects.Image) {\r\n                // Create a duplicate sprite on top with ADD blend mode\r\n                const overlay = this.scene.add.image(child.x, child.y, child.texture.key);\r\n                overlay.setOrigin(child.originX, child.originY);\r\n                overlay.setScale(child.scaleX, child.scaleY);\r\n                overlay.setBlendMode(Phaser.BlendModes.ADD);\r\n                overlay.setAlpha(0);\r\n                visual.add(overlay);\r\n                glowOverlays.push(overlay);\r\n            }\r\n        });\r\n\r\n        if (glowOverlays.length === 0) return;\r\n\r\n        visual.setData('glowOverlays', glowOverlays);\r\n\r\n        // Create pulsing tween on the overlay alphas\r\n        const tween = this.scene.tweens.add({\r\n            targets: glowOverlays,\r\n            alpha: { from: 0, to: 0.35 },\r\n            duration: 600,\r\n            yoyo: true,\r\n            repeat: -1,\r\n            ease: 'Sine.easeInOut'\r\n        });\r\n        visual.setData('glowTween', tween);\r\n    }\r\n\r\n    private stopGlowEffect(visual: Phaser.GameObjects.Container) {\r\n        const tween = visual.getData('glowTween') as Phaser.Tweens.Tween;\r\n        if (tween) {\r\n            tween.stop();\r\n            tween.destroy();\r\n            visual.setData('glowTween', null);\r\n        }\r\n\r\n        // Destroy overlay sprites\r\n        const glowOverlays = visual.getData('glowOverlays') as Phaser.GameObjects.Image[];\r\n        if (glowOverlays) {\r\n            glowOverlays.forEach(overlay => overlay.destroy());\r\n            visual.setData('glowOverlays', null);\r\n        }\r\n    }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\LGSM228\\CivStrategy\\game\\systems\\FeedbackSystem.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\LGSM228\\CivStrategy\\game\\systems\\FogOfWarSystem.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":152,"column":45,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":152,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5968,5971],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5968,5971],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":140,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":140,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5373,5376],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5373,5376],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\r\nimport Phaser from 'phaser';\r\nimport { MainScene } from '../MainScene';\r\nimport { UNIT_VISION } from '../../constants';\r\nimport { UnitType } from '../../types';\r\nimport { toIso } from '../utils/iso';\r\n\r\nexport class FogOfWarSystem {\r\n    private scene: MainScene;\r\n    private screenRT!: Phaser.GameObjects.RenderTexture;\r\n    private visionBrush: Phaser.GameObjects.Image;\r\n    private isVisible: boolean = true;\r\n\r\n    // Low res for performance\r\n    private readonly RES_SCALE = 0.25;\r\n\r\n    constructor(scene: MainScene) {\r\n        this.scene = scene;\r\n\r\n        // 1. Create Brush (Soft gradient)\r\n        const radius = 64;\r\n        const key = 'vision-brush-soft';\r\n\r\n        if (!this.scene.textures.exists(key)) {\r\n            const canvas = this.scene.textures.createCanvas(key, radius * 2, radius * 2);\r\n            if (canvas) {\r\n                const ctx = canvas.context;\r\n\r\n                const grd = ctx.createRadialGradient(radius, radius, 0, radius, radius, radius);\r\n                grd.addColorStop(0, 'rgba(0, 0, 0, 1)');\r\n                grd.addColorStop(0.4, 'rgba(0, 0, 0, 1)');\r\n                grd.addColorStop(1, 'rgba(0, 0, 0, 0)');\r\n\r\n                ctx.fillStyle = grd;\r\n                ctx.fillRect(0, 0, radius * 2, radius * 2);\r\n                canvas.refresh();\r\n            }\r\n        }\r\n\r\n        this.visionBrush = this.scene.make.image({ key: key, add: false });\r\n        this.visionBrush.setOrigin(0.5);\r\n\r\n        // 2. Initialize Render Texture\r\n        this.createRenderTexture();\r\n        this.scene.scale.on('resize', this.handleResize, this);\r\n    }\r\n\r\n    private createRenderTexture() {\r\n        if (this.screenRT) this.screenRT.destroy();\r\n\r\n        const width = Math.ceil(this.scene.scale.width * this.RES_SCALE);\r\n        const height = Math.ceil(this.scene.scale.height * this.RES_SCALE);\r\n\r\n        this.screenRT = this.scene.add.renderTexture(0, 0, width, height);\r\n        this.screenRT.setOrigin(0, 0);\r\n        this.screenRT.setScrollFactor(0);\r\n        // Initial scale, will be updated in update() loop\r\n        this.screenRT.setScale(1 / this.RES_SCALE);\r\n        this.screenRT.setDepth(10000);\r\n    }\r\n\r\n    private handleResize() {\r\n        this.createRenderTexture();\r\n    }\r\n\r\n    public update() {\r\n        if (!this.screenRT || !this.isVisible) return;\r\n\r\n        this.screenRT.clear();\r\n        this.screenRT.fill(0x000000, 1.0);\r\n\r\n        const cam = this.scene.cameras.main;\r\n        const zoom = cam.zoom;\r\n        const width = cam.width;\r\n        const height = cam.height;\r\n\r\n        // --- FIX FOR ZOOM SCALING ---\r\n        // We want the Fog RT to always cover the screen exactly, regardless of zoom.\r\n        // Since the camera applies zoom to all objects (even scrollFactor 0),\r\n        // we must counter-scale and counter-position the RT.\r\n\r\n        // 1. Counter-Scale: If zoom is 0.5 (smaller), we scale RT up by 2.\r\n        const baseScale = 1 / this.RES_SCALE;\r\n        const targetScale = baseScale / zoom;\r\n        this.screenRT.setScale(targetScale);\r\n\r\n        // 2. Counter-Position: Keep top-left at (0,0) on screen.\r\n        // Camera Zoom pivots around center. \r\n        // Formula to keep Top-Left (0,0) fixed: Center * (1 - 1/Zoom)\r\n        const offsetX = (width * 0.5) * (1 - 1 / zoom);\r\n        const offsetY = (height * 0.5) * (1 - 1 / zoom);\r\n        this.screenRT.setPosition(offsetX, offsetY);\r\n\r\n        // --- DRAWING HOLES ---\r\n\r\n        // Get the exact world position of the top-left of the screen\r\n        const topLeft = cam.getWorldPoint(0, 0);\r\n\r\n        // Calculate scaling factor from World Distance -> RT Pixels\r\n        // World -> Screen = * Zoom\r\n        // Screen -> RT = * RES_SCALE\r\n        const globalScale = zoom * this.RES_SCALE;\r\n\r\n        // Helper function\r\n        const drawVision = (worldX: number, worldY: number, worldRadius: number) => {\r\n            // 1. Calculate World Delta from Camera Top-Left\r\n            const relWorldX = worldX - topLeft.x;\r\n            const relWorldY = worldY - topLeft.y;\r\n\r\n            // 2. Convert to RT Coordinates\r\n            const drawX = relWorldX * globalScale;\r\n            const drawY = relWorldY * globalScale;\r\n\r\n            // 3. Calculate Brush Scale\r\n            // Visual Radius on Screen = WorldRadius * Zoom\r\n            // Radius in RT Pixels = ScreenRadius * RES_SCALE\r\n            const rtRadius = worldRadius * globalScale;\r\n\r\n            // Brush texture is 128x128 (Radius 64)\r\n            const brushScale = rtRadius / 64;\r\n\r\n            // Apply Isometric distortion (2:1 ratio) + extra size for fade\r\n            this.visionBrush.setScale(brushScale * 2.5, brushScale * 1.25);\r\n            this.visionBrush.setPosition(drawX, drawY);\r\n\r\n            this.screenRT.erase(this.visionBrush);\r\n        };\r\n\r\n        // Padding for culling (in world units)\r\n        // Increased padding to ensure large light sources (like TC with 600 radius)\r\n        // are still drawn even if their center is off-screen.\r\n        const padding = 1000 / zoom;\r\n        const viewRect = cam.worldView;\r\n\r\n        // 2. Process Units\r\n        const units = this.scene.units.getChildren();\r\n        for (let i = 0; i < units.length; i++) {\r\n            const u = units[i] as Phaser.GameObjects.Sprite;\r\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n            if ((u as any).unitType === UnitType.ANIMAL) continue;\r\n\r\n            // Fix: Enemy units do not reveal fog\r\n            if (u.getData('owner') !== 0) continue;\r\n\r\n            // Convert Logic Coordinates (Cartesian) to Visual Coordinates (Isometric)\r\n            // The camera looks at Iso coords, so fog must be drawn at Iso coords.\r\n            const iso = toIso(u.x, u.y);\r\n\r\n            if (iso.x < viewRect.x - padding || iso.x > viewRect.right + padding ||\r\n                iso.y < viewRect.y - padding || iso.y > viewRect.bottom + padding) continue;\r\n\r\n            const range = UNIT_VISION[(u as any).unitType as UnitType] || 150;\r\n            drawVision(iso.x, iso.y, range);\r\n        }\r\n\r\n        // 3. Process Buildings\r\n        const buildings = this.scene.buildings.getChildren();\r\n        for (let i = 0; i < buildings.length; i++) {\r\n            const b = buildings[i] as Phaser.GameObjects.Image; // or Rectangle\r\n\r\n            // Fix: Enemy buildings do not reveal fog\r\n            if (b.getData('owner') !== 0) continue;\r\n\r\n            // Convert Logic Coordinates (Cartesian) to Visual Coordinates (Isometric)\r\n            const iso = toIso(b.x, b.y);\r\n\r\n            if (iso.x < viewRect.x - padding || iso.x > viewRect.right + padding ||\r\n                iso.y < viewRect.y - padding || iso.y > viewRect.bottom + padding) continue;\r\n\r\n            const def = b.getData('def');\r\n            const range = def.territoryRadius || def.visionRadius || 200;\r\n            drawVision(iso.x, iso.y, range);\r\n        }\r\n    }\r\n\r\n    public destroy() {\r\n        if (this.screenRT) this.screenRT.destroy();\r\n        this.scene.scale.off('resize', this.handleResize, this);\r\n    }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\LGSM228\\CivStrategy\\game\\systems\\InfiniteMapSystem.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\LGSM228\\CivStrategy\\game\\systems\\InputManager.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'UnitState' is defined but never used. Allowed unused vars must match /^_/u.","line":5,"column":20,"nodeType":null,"messageId":"unusedVar","endLine":5,"endColumn":29},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'FactionType' is defined but never used. Allowed unused vars must match /^_/u.","line":5,"column":31,"nodeType":null,"messageId":"unusedVar","endLine":5,"endColumn":42},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":64,"column":67,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":64,"endColumn":70,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2829,2832],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2829,2832],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":106,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":106,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4495,4498],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4495,4498],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":107,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":107,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4573,4576],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4573,4576],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":118,"column":52,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":118,"endColumn":55,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4929,4932],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4929,4932],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":129,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":129,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5371,5374],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5371,5374],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":197,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":197,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7960,7963],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7960,7963],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":201,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":201,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8191,8194],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8191,8194],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":227,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":227,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9289,9292],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9289,9292],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":229,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":229,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9416,9419],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9416,9419],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":239,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":239,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9964,9967],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9964,9967],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":239,"column":47,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":239,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9988,9991],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9988,9991],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":240,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":240,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10087,10090],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10087,10090],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":255,"column":52,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":255,"endColumn":55,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10675,10678],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10675,10678],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":277,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":277,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11504,11507],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11504,11507],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":285,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":285,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11801,11804],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11801,11804],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":298,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":298,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12219,12222],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12219,12222],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":298,"column":87,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":298,"endColumn":90,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12263,12266],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12263,12266],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":299,"column":49,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":299,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12378,12381],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12378,12381],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":236,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":236,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9777,9780],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9777,9780],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":236,"column":51,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":236,"endColumn":54,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9801,9804],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9801,9804],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":20,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\r\nimport Phaser from 'phaser';\r\nimport { MainScene } from '../MainScene';\r\nimport { EVENTS } from '../../constants';\r\nimport { UnitType, UnitState, FactionType } from '../../types';\r\nimport { toCartesian } from '../utils/iso';\r\n\r\nexport class InputManager {\r\n    private scene: MainScene;\r\n    public selectedUnits: Phaser.GameObjects.GameObject[] = [];\r\n    public selectedBuilding: Phaser.GameObjects.GameObject | null = null;\r\n\r\n    private isDragging = false;\r\n    private dragStart = new Phaser.Math.Vector2();\r\n    private dragRect = new Phaser.Geom.Rectangle();\r\n    private selectionGraphics: Phaser.GameObjects.Graphics;\r\n\r\n    private lastClickTime = 0;\r\n    private lastClickPos = new Phaser.Math.Vector2();\r\n\r\n    constructor(scene: MainScene) {\r\n        this.scene = scene;\r\n        this.selectionGraphics = this.scene.add.graphics().setDepth(Number.MAX_VALUE);\r\n        this.setupInputs();\r\n    }\r\n\r\n    private setupInputs() {\r\n        this.scene.input.on('pointerdown', this.handlePointerDown, this);\r\n        this.scene.input.on('pointermove', this.handlePointerMove, this);\r\n        this.scene.input.on('pointerup', this.handlePointerUp, this);\r\n        this.scene.input.on('wheel', (_pointer: Phaser.Input.Pointer, _gameObjects: Phaser.GameObjects.GameObject[], _deltaX: number, deltaY: number, _deltaZ: number) => {\r\n            this.handleZoom(deltaY);\r\n        });\r\n\r\n        this.scene.game.events.on('filter-selection', (type: UnitType) => {\r\n            this.filterSelectionByType(type);\r\n        });\r\n    }\r\n\r\n    public update(delta: number) {\r\n        this.handleCameraMovement(delta);\r\n    }\r\n\r\n    private handleZoom(deltaY: number) {\r\n        const newZoom = Phaser.Math.Clamp(this.scene.cameras.main.zoom - deltaY * 0.001, 0.5, 2);\r\n        this.scene.cameras.main.setZoom(newZoom);\r\n    }\r\n\r\n    private handleCameraMovement(delta: number) {\r\n        const speed = 1.0 * delta / this.scene.cameras.main.zoom;\r\n        if (this.scene.cursors.left.isDown || this.scene.wasd.A.isDown) this.scene.cameras.main.scrollX -= speed;\r\n        if (this.scene.cursors.right.isDown || this.scene.wasd.D.isDown) this.scene.cameras.main.scrollX += speed;\r\n        if (this.scene.cursors.up.isDown || this.scene.wasd.W.isDown) this.scene.cameras.main.scrollY -= speed;\r\n        if (this.scene.cursors.down.isDown || this.scene.wasd.S.isDown) this.scene.cameras.main.scrollY += speed;\r\n    }\r\n\r\n    private handlePointerDown(pointer: Phaser.Input.Pointer) {\r\n        if (pointer.rightButtonDown()) {\r\n            if (this.scene.buildingManager.isDemolishMode) {\r\n                this.scene.game.events.emit(EVENTS.TOGGLE_DEMOLISH, false);\r\n                return;\r\n            }\r\n            if (this.scene.buildingManager.previewBuildingType) {\r\n                this.scene.buildingManager.enterBuildMode(null as any); // Fix: Should be a specific type or handle null\r\n                this.scene.buildingManager.previewBuildingType = null;\r\n                if (this.scene.buildingManager.previewBuilding) this.scene.buildingManager.previewBuilding.destroy();\r\n                return;\r\n            }\r\n\r\n            this.handleRightClick(pointer);\r\n            return;\r\n        }\r\n\r\n        if (this.scene.buildingManager.isDemolishMode) {\r\n            this.scene.buildingManager.handleDemolishClick(pointer);\r\n            return;\r\n        }\r\n\r\n        if (this.scene.buildingManager.previewBuildingType) {\r\n            this.scene.buildingManager.tryBuild(pointer.worldX, pointer.worldY);\r\n        } else {\r\n            // DOUBLE CLICK DETECTION\r\n            const now = this.scene.time.now;\r\n            const dist = this.lastClickPos.distance(new Phaser.Math.Vector2(pointer.x, pointer.y));\r\n\r\n            if (now - this.lastClickTime < 300 && dist < 10) {\r\n                this.handleDoubleClick(pointer);\r\n                this.isDragging = false;\r\n                return;\r\n            }\r\n\r\n            this.lastClickTime = now;\r\n            this.lastClickPos.set(pointer.x, pointer.y);\r\n\r\n            this.isDragging = true;\r\n            this.dragStart.set(pointer.worldX, pointer.worldY);\r\n        }\r\n    }\r\n\r\n    private handleDoubleClick(pointer: Phaser.Input.Pointer) {\r\n        const targets = this.scene.input.hitTestPointer(pointer);\r\n        const unitVisual = targets.find((obj: Phaser.GameObjects.GameObject) => obj.getData && obj.getData('unit'));\r\n\r\n        if (unitVisual) {\r\n            const unit = unitVisual.getData('unit');\r\n            const type = (unit as any).unitType; // Fix: Cast to Unit or similar type\r\n            if ((unit as any).getData('owner') === 0 && this.isSelectable(type)) { // Fix: Owner 0 is Player\r\n                this.selectAllOfType(type);\r\n                return;\r\n            }\r\n        }\r\n    }\r\n\r\n    private selectAllOfType(type: UnitType) {\r\n        this.clearSelection();\r\n        this.deselectBuilding();\r\n\r\n        this.scene.units.getChildren().forEach((u: any) => { // Fix: Cast to Unit type\r\n            if (u.getData('owner') === 0 && u.unitType === type) { // Fix: Owner 0 is Player\r\n                u.setSelected(true);\r\n                this.selectedUnits.push(u);\r\n            }\r\n        });\r\n        this.emitSelectionChanged();\r\n    }\r\n\r\n    private filterSelectionByType(type: UnitType) {\r\n        const toKeep: Phaser.GameObjects.GameObject[] = [];\r\n        this.selectedUnits.forEach((u: any) => { // Fix: Cast to Unit type\r\n            if (u.unitType === type) {\r\n                toKeep.push(u);\r\n            } else {\r\n                u.setSelected(false);\r\n            }\r\n        });\r\n\r\n        this.selectedUnits = toKeep;\r\n        this.emitSelectionChanged();\r\n    }\r\n\r\n    private handlePointerMove(pointer: Phaser.Input.Pointer) {\r\n        if (this.scene.buildingManager.isDemolishMode) {\r\n            this.scene.buildingManager.handleDemolishHover(pointer);\r\n            return;\r\n        }\r\n\r\n        if (this.isDragging) {\r\n            this.dragRect.setTo(\r\n                Math.min(this.dragStart.x, pointer.worldX),\r\n                Math.min(this.dragStart.y, pointer.worldY),\r\n                Math.abs(pointer.worldX - this.dragStart.x),\r\n                Math.abs(pointer.worldY - this.dragStart.y)\r\n            );\r\n\r\n            this.selectionGraphics.clear();\r\n            this.selectionGraphics.lineStyle(2, 0xffffff);\r\n            this.selectionGraphics.strokeRectShape(this.dragRect);\r\n            this.selectionGraphics.fillStyle(0xffffff, 0.1);\r\n            this.selectionGraphics.fillRectShape(this.dragRect);\r\n        }\r\n\r\n        if (this.scene.buildingManager.previewBuildingType) {\r\n            this.scene.buildingManager.updatePreview(pointer.worldX, pointer.worldY);\r\n        }\r\n    }\r\n\r\n    private handlePointerUp(pointer: Phaser.Input.Pointer) {\r\n        if (this.isDragging) {\r\n            this.isDragging = false;\r\n            const dist = Phaser.Math.Distance.Between(\r\n                this.dragStart.x, this.dragStart.y,\r\n                pointer.worldX, pointer.worldY\r\n            );\r\n            this.selectionGraphics.clear();\r\n            if (dist < 5) {\r\n                this.handleSingleSelection(pointer);\r\n            } else {\r\n                this.selectUnitsInIsoRect(this.dragRect);\r\n            }\r\n        }\r\n    }\r\n\r\n    private handleRightClick(pointer: Phaser.Input.Pointer) {\r\n        if (this.selectedUnits.length === 0) return;\r\n\r\n        // Check for click on Enemy Unit/Building\r\n        const targets = this.scene.input.hitTestPointer(pointer);\r\n\r\n        const unitVisual = targets.find((obj: Phaser.GameObjects.GameObject) => obj.getData && obj.getData('unit'));\r\n        const buildingVisual = targets.find((obj: Phaser.GameObjects.GameObject) => obj.getData && obj.getData('building'));\r\n\r\n        let targetEntity: Phaser.GameObjects.GameObject | null = null;\r\n        let isEnemy = false;\r\n\r\n        if (unitVisual) {\r\n            targetEntity = unitVisual.getData('unit');\r\n            const owner = (targetEntity as any).getData('owner');\r\n            if (targetEntity && owner !== 0) isEnemy = true;\r\n        } else if (buildingVisual) {\r\n            targetEntity = buildingVisual.getData('building');\r\n            const owner = (targetEntity as any).getData('owner');\r\n            if (targetEntity && owner !== 0) isEnemy = true;\r\n        }\r\n\r\n        if (isEnemy && targetEntity) {\r\n            this.scene.unitSystem.commandAttack(this.selectedUnits, targetEntity);\r\n        } else {\r\n            // Standard Move\r\n            const cart = toCartesian(pointer.worldX, pointer.worldY);\r\n            this.scene.unitSystem.commandMove(this.selectedUnits, new Phaser.Math.Vector2(cart.x, cart.y));\r\n        }\r\n    }\r\n\r\n    private handleSingleSelection(pointer: Phaser.Input.Pointer) {\r\n        const targets = this.scene.input.hitTestPointer(pointer);\r\n        const unitVisual = targets.find((obj: Phaser.GameObjects.GameObject) => obj.getData && obj.getData('unit'));\r\n        const buildingVisual = targets.find((obj: Phaser.GameObjects.GameObject) => obj.getData && obj.getData('building'));\r\n\r\n        this.clearSelection();\r\n\r\n        if (unitVisual || !buildingVisual) {\r\n            this.deselectBuilding();\r\n        }\r\n\r\n        if (unitVisual) {\r\n            const unit = unitVisual.getData('unit');\r\n            const type = (unit as any).unitType; // Fix: Cast to Unit or similar type\r\n            // Only select Player units\r\n            if (unit && (unit as any).getData('owner') === 0 && this.isSelectable(type)) { // Fix: Owner 0 is Player\r\n                unit.setSelected(true);\r\n                this.selectedUnits.push(unit);\r\n            }\r\n        } else if (buildingVisual) {\r\n            const b = buildingVisual.getData('building');\r\n            this.selectedUnits.forEach((u) => {\r\n                if ((u as any).setSelected) (u as any).setSelected(false); // eslint-disable-line @typescript-eslint/no-explicit-any\r\n            });\r\n            this.selectedBuilding = b;\r\n            if ((b as any).setSelected) (b as any).setSelected(true); // Fix: Cast to Building or similar type\r\n            const visual = (b as any).visual; // Fix: Cast to Building or similar type\r\n            const ring = visual.getData('ring');\r\n            if (ring) ring.visible = true;\r\n\r\n            const def = b.getData('def'); // Fix: Type should be BuildingDef if available, or a more generic type\r\n            this.scene.game.events.emit(EVENTS.BUILDING_SELECTED, def.type);\r\n        }\r\n\r\n        this.emitSelectionChanged();\r\n    }\r\n\r\n    private selectUnitsInIsoRect(rect: Phaser.Geom.Rectangle) {\r\n        this.clearSelection();\r\n        this.deselectBuilding();\r\n\r\n        this.scene.units.getChildren().forEach((u: any) => { // Fix: Cast to Unit type\r\n            // Only select Player units in combat roles\r\n            if (u.getData('owner') !== 0) return; // Fix: Owner 0 is Player\r\n            if (!this.isSelectable(u.unitType)) return;\r\n\r\n            const visual = u.visual;\r\n            if (visual) {\r\n                const inside = rect.contains(visual.x, visual.y);\r\n                if (inside) {\r\n                    u.setSelected(true);\r\n                    this.selectedUnits.push(u);\r\n                }\r\n            }\r\n        });\r\n        this.emitSelectionChanged();\r\n    }\r\n\r\n    private isSelectable(type: UnitType) {\r\n        return type === UnitType.SOLDIER || type === UnitType.CAVALRY || type === UnitType.ARCHER || type === UnitType.LEGION;\r\n    }\r\n\r\n    public clearSelection() {\r\n        this.selectedUnits.forEach((u: any) => u.setSelected(false)); // Fix: Cast to Unit type\r\n        this.selectedUnits = [];\r\n        this.emitSelectionChanged();\r\n    }\r\n\r\n    private emitSelectionChanged() {\r\n        // Aggregate Counts\r\n        const counts: Record<string, number> = {};\r\n        this.selectedUnits.forEach((u: any) => { // Fix: Cast to Unit type\r\n            const type = u.unitType;\r\n            counts[type] = (counts[type] || 0) + 1;\r\n        });\r\n\r\n        this.scene.game.events.emit(EVENTS.SELECTION_CHANGED, {\r\n            count: this.selectedUnits.length,\r\n            counts: counts\r\n        });\r\n    }\r\n\r\n    public deselectBuilding() {\r\n        if (this.selectedBuilding) {\r\n            if ((this.selectedBuilding as any).setSelected) (this.selectedBuilding as any).setSelected(false); // Fix: Cast to Building or similar type\r\n            const v = (this.selectedBuilding as any).visual; // Fix: Cast to Building or similar type\r\n            if (v) {\r\n                const ring = v.getData('ring');\r\n                if (ring) ring.visible = false;\r\n            }\r\n            this.selectedBuilding = null;\r\n            this.scene.game.events.emit(EVENTS.BUILDING_SELECTED, null);\r\n        }\r\n    }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\LGSM228\\CivStrategy\\game\\systems\\MapGenerationSystem.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'MAP_SIZES' is defined but never used. Allowed unused vars must match /^_/u.","line":3,"column":21,"nodeType":null,"messageId":"unusedVar","endLine":3,"endColumn":30}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import Phaser from 'phaser';\r\nimport { MainScene } from '../MainScene';\r\nimport { TILE_SIZE, MAP_SIZES } from '../../constants';\r\nimport { toIso } from '../utils/iso';\r\nimport { UnitType } from '../../types';\r\n\r\nexport class MapGenerationSystem {\r\n    private scene: MainScene;\r\n\r\n    constructor(scene: MainScene) {\r\n        this.scene = scene;\r\n    }\r\n\r\n    createEnvironment() {\r\n        const p1 = toIso(0, 0);\r\n        const p2 = toIso(this.scene.mapWidth, 0);\r\n        const p3 = toIso(this.scene.mapWidth, this.scene.mapHeight);\r\n        const p4 = toIso(0, this.scene.mapHeight);\r\n\r\n        const border = this.scene.add.graphics();\r\n        border.lineStyle(8, 0x000000, 0.4);\r\n        border.beginPath();\r\n        border.moveTo(p1.x, p1.y);\r\n        border.lineTo(p2.x, p2.y);\r\n        border.lineTo(p3.x, p3.y);\r\n        border.lineTo(p4.x, p4.y);\r\n        border.closePath();\r\n        border.strokePath();\r\n        border.setDepth(-19000);\r\n\r\n        const grid = this.scene.add.graphics();\r\n        grid.lineStyle(2, 0x000000, 0.15);\r\n        const gridSpacing = TILE_SIZE * 4;\r\n        for (let x = 0; x <= this.scene.mapWidth; x += gridSpacing) {\r\n            const start = toIso(x, 0);\r\n            const end = toIso(x, this.scene.mapHeight);\r\n            grid.moveTo(start.x, start.y);\r\n            grid.lineTo(end.x, end.y);\r\n        }\r\n        for (let y = 0; y <= this.scene.mapHeight; y += gridSpacing) {\r\n            const start = toIso(0, y);\r\n            const end = toIso(this.scene.mapWidth, y);\r\n            grid.moveTo(start.x, start.y);\r\n            grid.lineTo(end.x, end.y);\r\n        }\r\n        grid.strokePath();\r\n        grid.setDepth(-9999);\r\n    }\r\n\r\n    generateFertileZones() {\r\n        const zoneCount = Math.floor((this.scene.mapWidth * this.scene.mapHeight) / (500 * 500));\r\n        for (let i = 0; i < zoneCount; i++) {\r\n            const x = Phaser.Math.Between(150, this.scene.mapWidth - 150);\r\n            const y = Phaser.Math.Between(150, this.scene.mapHeight - 150);\r\n            const radius = Phaser.Math.Between(100, 180);\r\n            this.scene.fertileZones.push(new Phaser.Geom.Circle(x, y, radius));\r\n            const iso = toIso(x, y);\r\n            const graphics = this.scene.add.graphics();\r\n            graphics.setDepth(-9500);\r\n            graphics.fillStyle(0x3e2723, 0.4);\r\n            graphics.fillEllipse(iso.x, iso.y, radius * 2, radius);\r\n        }\r\n    }\r\n\r\n    generateForestsAndAnimals() {\r\n        const forestCount = Math.floor((this.scene.mapWidth * this.scene.mapHeight) / (800 * 800));\r\n        for (let i = 0; i < forestCount; i++) {\r\n            const fx = Phaser.Math.Between(100, this.scene.mapWidth - 100);\r\n            const fy = Phaser.Math.Between(100, this.scene.mapHeight - 100);\r\n            const fRadius = Phaser.Math.Between(200, 450);\r\n            const treeCount = Math.floor(fRadius * 0.4);\r\n            for (let j = 0; j < treeCount; j++) {\r\n                const angle = Math.random() * Math.PI * 2;\r\n                const dist = Math.sqrt(Math.random()) * fRadius;\r\n                const tx = fx + Math.cos(angle) * dist;\r\n                const ty = fy + Math.sin(angle) * dist;\r\n                if (Phaser.Math.Distance.Between(tx, ty, this.scene.mapWidth / 2, this.scene.mapHeight / 2) > 250) {\r\n                    if (tx > 50 && tx < this.scene.mapWidth - 50 && ty > 50 && ty < this.scene.mapHeight - 50) {\r\n                        this.scene.entityFactory.spawnTree(tx, ty);\r\n                    }\r\n                }\r\n            }\r\n            const animalCount = Phaser.Math.Between(2, 5);\r\n            for (let k = 0; k < animalCount; k++) {\r\n                const angle = Math.random() * Math.PI * 2;\r\n                const ax = fx + Math.cos(angle) * (fRadius * 0.8);\r\n                const ay = fy + Math.sin(angle) * (fRadius * 0.8);\r\n                if (Phaser.Math.Distance.Between(ax, ay, this.scene.mapWidth / 2, this.scene.mapHeight / 2) > 300) {\r\n                    if (ax > 50 && ax < this.scene.mapWidth - 50 && ay > 50 && ay < this.scene.mapHeight - 50) {\r\n                        this.scene.entityFactory.spawnUnit(UnitType.ANIMAL, ax, ay, -1);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\LGSM228\\CivStrategy\\game\\systems\\MinimapSystem.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":128,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":128,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4900,4903],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4900,4903],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":171,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":171,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6383,6386],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6383,6386],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":191,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":191,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7223,7226],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7223,7226],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":229,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":229,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8499,8502],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8499,8502],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":245,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":245,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9204,9207],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9204,9207],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\r\nimport Phaser from 'phaser';\r\nimport { MainScene } from '../MainScene';\r\nimport { MapMode, UnitType } from '../../types';\r\nimport { UNIT_VISION } from '../../constants';\r\nimport { toCartesian } from '../utils/iso';\r\n\r\nexport class MinimapSystem {\r\n    private scene: MainScene;\r\n    private renderTexture: Phaser.GameObjects.RenderTexture;\r\n    private staticTexture: Phaser.GameObjects.RenderTexture;\r\n\r\n    private mapSize = 192; // Match React UI w-48\r\n    private padding = 24;  // Match React UI bottom-6 left-6\r\n\r\n    private unitDot: Phaser.GameObjects.Graphics;\r\n    private buildingRect: Phaser.GameObjects.Graphics;\r\n    private viewportGraphics: Phaser.GameObjects.Graphics;\r\n\r\n    private maskGraphics: Phaser.GameObjects.Graphics;\r\n    private borderGraphics: Phaser.GameObjects.Graphics;\r\n\r\n    private updateInterval = 15;\r\n    private frameCount = 0;\r\n    private dirtyStatic = true; // Flag to redraw static layer\r\n\r\n    private fogRT: Phaser.GameObjects.RenderTexture;\r\n    private fogBrush: Phaser.GameObjects.Graphics;\r\n\r\n    constructor(scene: MainScene) {\r\n        this.scene = scene;\r\n\r\n        // 1. Create Render Textures\r\n        this.renderTexture = this.scene.add.renderTexture(0, 0, this.mapSize, this.mapSize);\r\n        this.renderTexture.setOrigin(0, 0).setScrollFactor(0).setDepth(20000);\r\n\r\n        // Static layer for trees, background, resources (cached)\r\n        this.staticTexture = this.scene.make.renderTexture({ width: this.mapSize, height: this.mapSize }, false);\r\n        this.staticTexture.setOrigin(0, 0);\r\n\r\n        // Fog Layer\r\n        this.fogRT = this.scene.add.renderTexture(0, 0, this.mapSize, this.mapSize);\r\n        this.fogRT.setOrigin(0, 0).setScrollFactor(0).setDepth(20002); // Above map, below border\r\n        this.fogRT.setAlpha(1.0); // Full black\r\n\r\n        // 2. Create Reusable 'Brushes'\r\n        this.unitDot = this.scene.make.graphics({});\r\n        this.unitDot.setVisible(false);\r\n\r\n        this.buildingRect = this.scene.make.graphics({});\r\n        this.buildingRect.setVisible(false);\r\n\r\n        this.viewportGraphics = this.scene.make.graphics({});\r\n        this.viewportGraphics.setVisible(false);\r\n\r\n        this.fogBrush = this.scene.make.graphics({});\r\n        this.fogBrush.setVisible(false);\r\n\r\n        // 3. Circular Mask\r\n        this.maskGraphics = this.scene.make.graphics({});\r\n        this.maskGraphics.fillStyle(0xffffff);\r\n        this.maskGraphics.fillCircle(this.mapSize / 2, this.mapSize / 2, this.mapSize / 2);\r\n        this.maskGraphics.setScrollFactor(0).setVisible(false);\r\n\r\n        const mask = this.maskGraphics.createGeometryMask();\r\n        this.renderTexture.setMask(mask);\r\n        this.fogRT.setMask(mask);\r\n\r\n        // 4. Border\r\n        this.borderGraphics = this.scene.add.graphics();\r\n        this.borderGraphics.setScrollFactor(0).setDepth(20003); // Top most\r\n\r\n        // Initial Layout\r\n        this.updateLayout();\r\n    }\r\n\r\n    public refreshStaticLayer() {\r\n        this.dirtyStatic = true;\r\n    }\r\n\r\n    private updateLayout() {\r\n        const cam = this.scene.cameras.main;\r\n        const zoom = cam.zoom;\r\n        const invZoom = 1 / zoom;\r\n        const w = this.scene.scale.width;\r\n        const h = this.scene.scale.height;\r\n\r\n        const targetX = this.padding;\r\n        const targetY = h - this.mapSize - this.padding;\r\n\r\n        const x = (targetX - w * 0.5) * invZoom + w * 0.5;\r\n        const y = (targetY - h * 0.5) * invZoom + h * 0.5;\r\n\r\n        this.renderTexture.setPosition(x, y).setScale(invZoom);\r\n        this.fogRT.setPosition(x, y).setScale(invZoom);\r\n        this.maskGraphics.setPosition(x, y).setScale(invZoom);\r\n\r\n        this.borderGraphics.setPosition(x, y).setScale(invZoom);\r\n        this.borderGraphics.clear();\r\n        this.borderGraphics.lineStyle(3 * zoom, 0x44403c, 1.0);\r\n        this.borderGraphics.strokeCircle(this.mapSize / 2, this.mapSize / 2, this.mapSize / 2);\r\n    }\r\n\r\n    private drawStaticLayer(scalar: number) {\r\n        this.staticTexture.clear();\r\n        this.staticTexture.fill(0x064e3b); // Background\r\n\r\n        // Draw Fertile Zones\r\n        this.buildingRect.clear();\r\n        this.buildingRect.fillStyle(0x451a03, 0.5);\r\n        for (const zone of this.scene.fertileZones) {\r\n            const pos = this.worldToMini(zone.x, zone.y, scalar);\r\n            if (this.isInBounds(pos)) {\r\n                const r = zone.radius * scalar;\r\n                this.buildingRect.fillCircle(0, 0, r);\r\n                this.staticTexture.draw(this.buildingRect, pos.x, pos.y);\r\n            }\r\n        }\r\n\r\n        // Draw Trees (The heavy part)\r\n        this.unitDot.clear();\r\n        this.unitDot.fillStyle(0x022c22, 0.8);\r\n\r\n        // Batch all tree drawings into the Graphics object first\r\n        const trees = this.scene.trees.getChildren();\r\n        let treesDrawn = 0;\r\n        for (const t of trees) {\r\n            const tree = t as any;\r\n            if (tree.getData('isChopped')) continue; // Don't draw chopped trees\r\n\r\n            const pos = this.worldToMini(tree.x, tree.y, scalar);\r\n            if (this.isInBounds(pos)) {\r\n                // Direct fill circle on graphics, do NOT draw to texture yet\r\n                this.unitDot.fillCircle(pos.x, pos.y, 1.5);\r\n                treesDrawn++;\r\n            }\r\n        }\r\n\r\n        // Single draw call to RenderTexture\r\n        if (treesDrawn > 0) {\r\n            this.staticTexture.draw(this.unitDot, 0, 0);\r\n        }\r\n    }\r\n\r\n    private isInBounds(pos: { x: number, y: number }) {\r\n        return pos.x >= -10 && pos.x <= this.mapSize + 10 && pos.y >= -10 && pos.y <= this.mapSize + 10;\r\n    }\r\n\r\n    public update() {\r\n        this.updateLayout();\r\n\r\n        this.frameCount++;\r\n        if (this.frameCount < this.updateInterval) return;\r\n        this.frameCount = 0;\r\n\r\n        const scalar = this.getMapScalar();\r\n\r\n        // 1. Update Static Layer if needed\r\n        if (this.dirtyStatic) {\r\n            this.drawStaticLayer(scalar);\r\n            this.dirtyStatic = false;\r\n        }\r\n\r\n        // 2. Clear Main Texture and Draw Static Layer\r\n        this.renderTexture.clear();\r\n        this.renderTexture.draw(this.staticTexture, 0, 0);\r\n\r\n        // 3. Draw Buildings (Dynamic ownership/health, so draw every time)\r\n        const buildings = this.scene.buildings.getChildren();\r\n        for (const b of buildings) {\r\n            const build = b as any;\r\n            const pos = this.worldToMini(build.x, build.y, scalar);\r\n\r\n            if (this.isInBounds(pos)) {\r\n                const def = build.getData('def');\r\n                const owner = build.getData('owner');\r\n                const color = owner === 0 ? 0x3b82f6 : (owner === 1 ? 0xef4444 : 0xaaaaaa);\r\n                const size = Math.max(3, def.width * scalar);\r\n\r\n                this.buildingRect.clear();\r\n                this.buildingRect.fillStyle(color, 1);\r\n                this.buildingRect.fillRect(-size / 2, -size / 2, size, size);\r\n                this.renderTexture.draw(this.buildingRect, pos.x, pos.y);\r\n            }\r\n        }\r\n\r\n        // 4. Draw Units\r\n        const units = this.scene.units.getChildren();\r\n        this.unitDot.clear();\r\n        for (const u of units) {\r\n            const unit = u as any;\r\n            const pos = this.worldToMini(unit.x, unit.y, scalar);\r\n\r\n            if (this.isInBounds(pos)) {\r\n                const type = unit.unitType;\r\n                const owner = unit.getData('owner');\r\n                let color = owner === 0 ? 0x60a5fa : (owner === 1 ? 0xf87171 : 0xffffff);\r\n                let radius = 2.5;\r\n                if (type === UnitType.ANIMAL) { color = 0x9ca3af; radius = 1; }\r\n\r\n                this.unitDot.fillStyle(color, 1);\r\n                this.unitDot.fillCircle(0, 0, radius);\r\n                this.renderTexture.draw(this.unitDot, pos.x, pos.y);\r\n            }\r\n        }\r\n\r\n        // 5. Update Fog of War\r\n        this.updateFog(scalar);\r\n\r\n        // 6. Viewport\r\n        this.drawViewport(scalar);\r\n    }\r\n\r\n    private updateFog(scalar: number) {\r\n        if (!this.scene.isFowEnabled) {\r\n            this.fogRT.setVisible(false);\r\n            return;\r\n        }\r\n        this.fogRT.setVisible(true);\r\n        this.fogRT.clear();\r\n        this.fogRT.fill(0x000000, 1.0);\r\n\r\n        // Use custom blend mode to Erase\r\n        this.fogBrush.clear();\r\n        this.fogBrush.fillStyle(0xffffff, 1);\r\n\r\n        const units = this.scene.units.getChildren();\r\n        for (const u of units) {\r\n            const unit = u as any;\r\n            // Only friendly units reveal fog\r\n            if (unit.getData('owner') !== 0) continue;\r\n            // Animals don't reveal fog (usually)\r\n            if (unit.unitType === UnitType.ANIMAL) continue;\r\n\r\n            const pos = this.worldToMini(unit.x, unit.y, scalar);\r\n            if (this.isInBounds(pos)) {\r\n                // Approximate Minimap Vision radius\r\n                const range = (UNIT_VISION[unit.unitType as UnitType] || 250) * scalar * 1.5;\r\n                this.fogBrush.fillCircle(pos.x, pos.y, range);\r\n            }\r\n        }\r\n\r\n        const buildings = this.scene.buildings.getChildren();\r\n        for (const b of buildings) {\r\n            const build = b as any;\r\n            if (build.getData('owner') !== 0) continue;\r\n\r\n            const pos = this.worldToMini(build.x, build.y, scalar);\r\n            if (this.isInBounds(pos)) {\r\n                const def = build.getData('def');\r\n                // Use territory or vision radius\r\n                const range = (def.territoryRadius || def.visionRadius || 200) * scalar;\r\n                this.fogBrush.fillCircle(pos.x, pos.y, range);\r\n            }\r\n        }\r\n\r\n        // Erase using the brush\r\n        this.fogRT.erase(this.fogBrush);\r\n    }\r\n\r\n    private drawViewport(scalar: number) {\r\n        const cam = this.scene.cameras.main;\r\n        const tl = cam.getWorldPoint(0, 0);\r\n        const tr = cam.getWorldPoint(cam.width, 0);\r\n        const bl = cam.getWorldPoint(0, cam.height);\r\n        const br = cam.getWorldPoint(cam.width, cam.height);\r\n\r\n        const cTl = toCartesian(tl.x, tl.y);\r\n        const cTr = toCartesian(tr.x, tr.y);\r\n        const cBl = toCartesian(bl.x, bl.y);\r\n        const cBr = toCartesian(br.x, br.y);\r\n\r\n        const mTl = this.worldToMini(cTl.x, cTl.y, scalar);\r\n        const mTr = this.worldToMini(cTr.x, cTr.y, scalar);\r\n        const mBl = this.worldToMini(cBl.x, cBl.y, scalar);\r\n        const mBr = this.worldToMini(cBr.x, cBr.y, scalar);\r\n\r\n        this.viewportGraphics.clear();\r\n        this.viewportGraphics.lineStyle(2, 0xfacc15, 1.0);\r\n        this.viewportGraphics.beginPath();\r\n        this.viewportGraphics.moveTo(mTl.x, mTl.y);\r\n        this.viewportGraphics.lineTo(mTr.x, mTr.y);\r\n        this.viewportGraphics.lineTo(mBr.x, mBr.y);\r\n        this.viewportGraphics.lineTo(mBl.x, mBl.y);\r\n        this.viewportGraphics.closePath();\r\n        this.viewportGraphics.strokePath();\r\n\r\n        this.renderTexture.draw(this.viewportGraphics, 0, 0);\r\n    }\r\n\r\n    public getWorldFromMinimap(miniX: number, miniY: number): { x: number, y: number } {\r\n        const scalar = this.getMapScalar();\r\n        if (this.scene.mapMode === MapMode.INFINITE) {\r\n            const cam = this.scene.cameras.main;\r\n            const center = toCartesian(cam.worldView.centerX, cam.worldView.centerY);\r\n            const dx = miniX - this.mapSize / 2;\r\n            const dy = miniY - this.mapSize / 2;\r\n            return { x: center.x + dx / scalar, y: center.y + dy / scalar };\r\n        } else {\r\n            return { x: miniX / scalar, y: miniY / scalar };\r\n        }\r\n    }\r\n\r\n    private getMapScalar(): number {\r\n        const worldSize = this.scene.mapMode === MapMode.FIXED ? this.scene.mapWidth : 4096;\r\n        return this.mapSize / worldSize;\r\n    }\r\n\r\n    private worldToMini(x: number, y: number, scalar: number) {\r\n        if (this.scene.mapMode === MapMode.INFINITE) {\r\n            const cam = this.scene.cameras.main;\r\n            const center = toCartesian(cam.worldView.centerX, cam.worldView.centerY);\r\n            const dx = x - center.x;\r\n            const dy = y - center.y;\r\n            return { x: dx * scalar + this.mapSize / 2, y: dy * scalar + this.mapSize / 2 };\r\n        } else {\r\n            return { x: x * scalar, y: y * scalar };\r\n        }\r\n    }\r\n\r\n    public destroy() {\r\n        if (this.fogRT) this.fogRT.destroy();\r\n        if (this.fogBrush) this.fogBrush.destroy();\r\n        if (this.renderTexture) this.renderTexture.destroy();\r\n        if (this.staticTexture) this.staticTexture.destroy();\r\n        if (this.borderGraphics) this.borderGraphics.destroy();\r\n        if (this.maskGraphics) this.maskGraphics.destroy();\r\n        if (this.unitDot) this.unitDot.destroy();\r\n        if (this.buildingRect) this.buildingRect.destroy();\r\n        if (this.viewportGraphics) this.viewportGraphics.destroy();\r\n    }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\LGSM228\\CivStrategy\\game\\systems\\Pathfinder.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\LGSM228\\CivStrategy\\game\\systems\\SquadSystem.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'UnitStats' is defined but never used. Allowed unused vars must match /^_/u.","line":3,"column":20,"nodeType":null,"messageId":"unusedVar","endLine":3,"endColumn":29},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'FACTION_COLORS' is defined but never used. Allowed unused vars must match /^_/u.","line":4,"column":22,"nodeType":null,"messageId":"unusedVar","endLine":4,"endColumn":36},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'owner' is defined but never used. Allowed unused args must match /^_/u.","line":21,"column":77,"nodeType":null,"messageId":"unusedVar","endLine":21,"endColumn":82},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":50,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":50,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1752,1755],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1752,1755],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":72,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":72,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2592,2595],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2592,2595],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":73,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":73,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2639,2642],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2639,2642],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'dt' is defined but never used. Allowed unused args must match /^_/u.","line":81,"column":19,"nodeType":null,"messageId":"unusedVar","endLine":81,"endColumn":21},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":85,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":85,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3009,3012],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3009,3012],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":8,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import Phaser from 'phaser';\r\nimport { MainScene } from '../MainScene';\r\nimport { UnitType, UnitStats } from '../../types';\r\nimport { UNIT_STATS, FACTION_COLORS } from '../../constants';\r\nimport { toIso } from '../utils/iso';\r\n\r\ninterface SoldierState {\r\n    x: number;\r\n    y: number;\r\n    z: number;\r\n    offset: { x: number, y: number };\r\n}\r\n\r\nexport class SquadSystem {\r\n    private scene: MainScene;\r\n\r\n    constructor(scene: MainScene) {\r\n        this.scene = scene;\r\n    }\r\n\r\n    public createSquad(unit: Phaser.GameObjects.GameObject, type: UnitType, owner: number) {\r\n        const stats = UNIT_STATS[type];\r\n        if (!stats || stats.squadSize <= 1) return;\r\n\r\n        const container = this.scene.add.container(0, 0);\r\n        const gfx = this.scene.add.graphics();\r\n        container.add(gfx);\r\n\r\n        // Create unit indicator label (initially hidden)\r\n        const unitName = type === UnitType.LEGION ? 'LEGION' :\r\n            type === UnitType.SOLDIER ? 'SOLDIERS' :\r\n                type === UnitType.CAVALRY ? 'CAVALRY' : 'UNIT';\r\n        const indicatorLabel = this.scene.add.text(0, -26, unitName, {\r\n            fontFamily: 'Arial',\r\n            fontSize: '10px',\r\n            color: '#ffffff',\r\n            stroke: '#000000',\r\n            strokeThickness: 2\r\n        }).setOrigin(0.5).setVisible(false);\r\n        container.add(indicatorLabel);\r\n        unit.setData('indicatorLabel', indicatorLabel);\r\n\r\n        unit.setData('squadContainer', container);\r\n        unit.setData('squadCurrentCount', stats.squadSize);\r\n        unit.setData('squadMaxCount', stats.squadSize);\r\n        unit.setData('formationAngle', 0);\r\n\r\n        this.initializeSoldiers(unit, stats.squadSize, type);\r\n\r\n        const commanderVisual = (unit as any).visual as Phaser.GameObjects.Container;\r\n        if (commanderVisual) {\r\n            commanderVisual.setVisible(false);\r\n            commanderVisual.removeAll(true);\r\n        }\r\n\r\n        this.scene.add.existing(container);\r\n    }\r\n\r\n    private initializeSoldiers(unit: Phaser.GameObjects.GameObject, count: number, type: UnitType) {\r\n        const stats = UNIT_STATS[type];\r\n        const soldiers: SoldierState[] = [];\r\n        const spacing = stats.squadSpacing || 10;\r\n        const cols = Math.ceil(Math.sqrt(count));\r\n\r\n        for (let i = 0; i < count; i++) {\r\n            const col = i % cols;\r\n            const row = Math.floor(i / cols);\r\n            const offsetX = (col - cols / 2) * spacing;\r\n            const offsetY = (row - (count / cols) / 2) * spacing;\r\n\r\n            soldiers.push({\r\n                x: (unit as any).x + offsetX,\r\n                y: (unit as any).y + offsetY,\r\n                z: 0,\r\n                offset: { x: offsetX, y: offsetY }\r\n            });\r\n        }\r\n        unit.setData('soldierStates', soldiers);\r\n    }\r\n\r\n    public update(dt: number) {\r\n        const units = this.scene.units.getChildren();\r\n\r\n        units.forEach((uObj: Phaser.GameObjects.GameObject) => {\r\n            const unit = uObj as any;\r\n            const container = unit.getData('squadContainer') as Phaser.GameObjects.Container;\r\n            if (!container) return;\r\n\r\n            // Optimization: Skip processing if the squad container is culled\r\n            if (!container.visible) return;\r\n\r\n            const body = unit.body as Phaser.Physics.Arcade.Body;\r\n            const stats = UNIT_STATS[unit.unitType as UnitType];\r\n\r\n            let angle = unit.getData('formationAngle');\r\n            const speed = body.velocity.length();\r\n            const isMoving = speed > 10;\r\n\r\n            if (isMoving) {\r\n                const targetAngle = body.velocity.angle();\r\n                angle = Phaser.Math.Angle.RotateTo(angle, targetAngle, 0.1);\r\n                unit.setData('formationAngle', angle);\r\n            }\r\n\r\n            const commanderIso = toIso(unit.x, unit.y);\r\n            container.setPosition(commanderIso.x, commanderIso.y);\r\n            container.setDepth(commanderIso.y);\r\n\r\n            const hp = unit.getData('hp');\r\n            const maxHp = unit.getData('maxHp');\r\n            const targetCount = Math.ceil((hp / maxHp) * stats.squadSize);\r\n            const soldiers = unit.getData('soldierStates') as SoldierState[];\r\n\r\n            if (soldiers.length !== targetCount) {\r\n                if (soldiers.length > targetCount) {\r\n                    soldiers.splice(targetCount);\r\n                } else {\r\n                    while (soldiers.length < targetCount) {\r\n                        soldiers.push({\r\n                            x: unit.x,\r\n                            y: unit.y,\r\n                            z: 0,\r\n                            offset: { x: (Math.random() - 0.5) * 10, y: (Math.random() - 0.5) * 10 }\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n\r\n            const gfx = container.getAt(0) as Phaser.GameObjects.Graphics;\r\n            gfx.clear();\r\n\r\n            const owner = unit.getData('owner');\r\n            const color = this.scene.getFactionColor(owner);\r\n\r\n            const cos = Math.cos(angle);\r\n            const sin = Math.sin(angle);\r\n\r\n            if (unit.isSelected) {\r\n                gfx.lineStyle(2, 0xffffff, 0.8);\r\n                const radius = Math.sqrt(stats.squadSize) * (stats.squadSpacing || 10) * 0.7;\r\n                gfx.strokeEllipse(0, 0, radius * 2.5, radius * 1.5);\r\n            }\r\n\r\n            // Unit Indicator Icon (Global Toggle)\r\n            // Unit Indicator Icon (Global Toggle)\r\n            if (this.scene.showUnitIndicators && owner === 0) {\r\n                const indicatorY = -60; // Position above the squad\r\n                const circleRadius = 22;\r\n\r\n                // Background circle with border\r\n                gfx.fillStyle(0x1a1a2e, 0.95);\r\n                gfx.fillCircle(0, indicatorY, circleRadius);\r\n                gfx.lineStyle(2, 0xffffff, 0.9);\r\n                gfx.strokeCircle(0, indicatorY, circleRadius);\r\n\r\n                // Draw unit icon silhouette inside\r\n                gfx.fillStyle(0xffffff, 0.9);\r\n                if (unit.unitType === UnitType.SOLDIER || unit.unitType === UnitType.LEGION) {\r\n                    // Soldier icon: body + head + spear\r\n                    gfx.fillRect(-3, indicatorY - 8, 6, 12); // body\r\n                    gfx.fillCircle(0, indicatorY - 12, 4); // head\r\n                    gfx.fillRect(5, indicatorY - 14, 2, 18); // spear\r\n                    gfx.fillStyle(0x888888, 0.9);\r\n                    gfx.fillTriangle(6, indicatorY - 14, 4, indicatorY - 10, 8, indicatorY - 10); // spear tip\r\n                } else if (unit.unitType === UnitType.CAVALRY) {\r\n                    // Cavalry icon: horse shape + rider\r\n                    gfx.fillEllipse(0, indicatorY + 2, 16, 8); // horse body\r\n                    gfx.fillCircle(-6, indicatorY - 2, 3); // horse head\r\n                    gfx.fillRect(-2, indicatorY - 8, 4, 6); // rider body\r\n                    gfx.fillCircle(0, indicatorY - 12, 3); // rider head\r\n                } else if (unit.unitType === UnitType.ARCHER) {\r\n                    // Archer icon: Bow path\r\n                    gfx.lineStyle(2, 0xffffff, 1);\r\n                    gfx.beginPath();\r\n                    gfx.arc(0, indicatorY, 8, Phaser.Math.DegToRad(-45), Phaser.Math.DegToRad(45), false); // Bow curve\r\n                    gfx.strokePath();\r\n                    // Arrow\r\n                    gfx.lineStyle(1, 0xffffff, 1);\r\n                    gfx.beginPath();\r\n                    gfx.moveTo(-8, indicatorY);\r\n                    gfx.lineTo(8, indicatorY);\r\n                    gfx.strokePath();\r\n                }\r\n\r\n                // Unit type name below the indicator\r\n                const unitName = unit.unitType === UnitType.LEGION ? 'LEGION' :\r\n                    unit.unitType === UnitType.SOLDIER ? 'SOLDIERS' :\r\n                        unit.unitType === UnitType.ARCHER ? 'ARCHERS' :\r\n                            unit.unitType === UnitType.CAVALRY ? 'CAVALRY' : 'UNIT';\r\n\r\n                // Draw text background\r\n                const textY = indicatorY + circleRadius + 10;\r\n                gfx.fillStyle(0x000000, 0.7);\r\n                gfx.fillRoundedRect(-35, textY - 8, 70, 14, 4);\r\n\r\n                // Show and position the indicator label\r\n                const indicatorLabel = unit.getData('indicatorLabel') as Phaser.GameObjects.Text;\r\n                if (indicatorLabel) {\r\n                    indicatorLabel.setText(unitName); // Ensure name is correct\r\n                    indicatorLabel.setY(textY);\r\n                    indicatorLabel.setVisible(true);\r\n                }\r\n            } else {\r\n                // Hide indicator label when not showing\r\n                const indicatorLabel = unit.getData('indicatorLabel') as Phaser.GameObjects.Text;\r\n                if (indicatorLabel) {\r\n                    indicatorLabel.setVisible(false);\r\n                }\r\n            }\r\n\r\n            soldiers.forEach((soldier, index) => {\r\n                const dx = soldier.offset.x * cos - soldier.offset.y * sin;\r\n                const dy = soldier.offset.x * sin + soldier.offset.y * cos;\r\n                const targetX = unit.x + dx;\r\n                const targetY = unit.y + dy;\r\n\r\n                const lerpSpeed = isMoving ? 0.15 : 0.1;\r\n                soldier.x = Phaser.Math.Linear(soldier.x, targetX, lerpSpeed);\r\n                soldier.y = Phaser.Math.Linear(soldier.y, targetY, lerpSpeed);\r\n\r\n                if (isMoving) {\r\n                    soldier.z = Math.abs(Math.sin((this.scene.time.now / 150) + index)) * 3;\r\n                } else {\r\n                    soldier.z = Phaser.Math.Linear(soldier.z, 0, 0.2);\r\n                }\r\n\r\n                const isoSoldier = toIso(soldier.x, soldier.y);\r\n                const drawX = isoSoldier.x - commanderIso.x;\r\n                const drawY = isoSoldier.y - commanderIso.y - soldier.z;\r\n\r\n                if (unit.unitType === UnitType.LEGION || unit.unitType === UnitType.SOLDIER || unit.unitType === UnitType.ARCHER) {\r\n                    gfx.fillStyle(0x000000, 0.3);\r\n                    gfx.fillEllipse(drawX, drawY + soldier.z, 6, 3);\r\n                    gfx.fillStyle(color, 1);\r\n                    gfx.fillRect(drawX - 2, drawY - 4, 4, 6);\r\n                    gfx.fillStyle(0xffffff, 0.8);\r\n                    gfx.fillRect(drawX - 1, drawY - 6, 2, 2);\r\n                } else if (unit.unitType === UnitType.CAVALRY) {\r\n                    gfx.fillStyle(0x000000, 0.3);\r\n                    gfx.fillEllipse(drawX, drawY + soldier.z, 10, 5);\r\n                    gfx.fillStyle(color, 1);\r\n                    gfx.fillEllipse(drawX, drawY, 14, 8);\r\n                    gfx.fillStyle(0xffffff, 1);\r\n                    gfx.fillCircle(drawX, drawY - 5, 2.5);\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    public destroySquad(unit: Phaser.GameObjects.GameObject) {\r\n        const container = unit.getData('squadContainer') as Phaser.GameObjects.Container;\r\n        if (container) {\r\n            container.destroy();\r\n        }\r\n    }\r\n}","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\LGSM228\\CivStrategy\\game\\systems\\UnitSystem.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'UnitStats' is defined but never used. Allowed unused vars must match /^_/u.","line":4,"column":31,"nodeType":null,"messageId":"unusedVar","endLine":4,"endColumn":40},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'TILE_SIZE' is defined but never used. Allowed unused vars must match /^_/u.","line":5,"column":33,"nodeType":null,"messageId":"unusedVar","endLine":5,"endColumn":42},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":35,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":35,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1223,1226],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1223,1226],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":70,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":70,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2676,2679],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2676,2679],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error.","line":88,"column":17,"nodeType":"MemberExpression","messageId":"limited","endLine":88,"endColumn":28,"suggestions":[{"fix":{"range":[3619,3673],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error.","line":94,"column":17,"nodeType":"MemberExpression","messageId":"limited","endLine":94,"endColumn":28,"suggestions":[{"fix":{"range":[3909,3961],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":99,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":99,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4066,4069],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4066,4069],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error.","line":100,"column":13,"nodeType":"MemberExpression","messageId":"limited","endLine":100,"endColumn":24,"suggestions":[{"fix":{"range":[4094,4132],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":102,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":102,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4207,4210],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4207,4210],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error.","line":109,"column":13,"nodeType":"MemberExpression","messageId":"limited","endLine":109,"endColumn":24,"suggestions":[{"fix":{"range":[4385,4430],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'delta' is defined but never used. Allowed unused args must match /^_/u.","line":113,"column":43,"nodeType":null,"messageId":"unusedVar","endLine":113,"endColumn":48},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":115,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":115,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4636,4639],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4636,4639],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":180,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":180,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7821,7824],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7821,7824],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":181,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":181,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7858,7861],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7858,7861],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":195,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":195,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8471,8474],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8471,8474],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error.","line":220,"column":17,"nodeType":"MemberExpression","messageId":"limited","endLine":220,"endColumn":28,"suggestions":[{"fix":{"range":[9301,9375],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":232,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":232,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9776,9779],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9776,9779],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":232,"column":46,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":232,"endColumn":49,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9789,9792],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9789,9792],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error.","line":234,"column":9,"nodeType":"MemberExpression","messageId":"limited","endLine":234,"endColumn":20,"suggestions":[{"fix":{"range":[9856,9943],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":298,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":298,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12538,12541],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12538,12541],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":298,"column":47,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":298,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12551,12554],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12551,12554],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":363,"column":52,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":363,"endColumn":55,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15125,15128],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15125,15128],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":392,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":392,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16387,16390],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16387,16390],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":17,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\r\nimport Phaser from 'phaser';\r\nimport { MainScene } from '../MainScene';\r\nimport { UnitType, UnitState, UnitStats } from '../../types';\r\nimport { MAP_WIDTH, MAP_HEIGHT, TILE_SIZE, UNIT_SPEED, UNIT_STATS } from '../../constants';\r\nimport { toIso } from '../utils/iso';\r\n\r\nexport class UnitSystem {\r\n    private scene: MainScene;\r\n    private pathGraphics: Phaser.GameObjects.Graphics;\r\n    private debugGraphics: Phaser.GameObjects.Graphics;\r\n\r\n    constructor(scene: MainScene) {\r\n        this.scene = scene;\r\n        this.pathGraphics = this.scene.add.graphics().setDepth(-4000);\r\n        this.debugGraphics = this.scene.add.graphics().setDepth(100000);\r\n    }\r\n\r\n    public update(time: number, delta: number) {\r\n        this.updateUnitLogic(time, delta);\r\n        this.drawUnitPaths(time);\r\n\r\n        if (this.scene.debugMode) {\r\n            this.drawDebugLines();\r\n        } else {\r\n            this.debugGraphics.clear();\r\n        }\r\n    }\r\n\r\n    public commandMove(units: Phaser.GameObjects.GameObject[], target: Phaser.Math.Vector2) {\r\n        const spacing = 15;\r\n        const formationCols = Math.ceil(Math.sqrt(units.length));\r\n\r\n        units.forEach((unitObj, index) => {\r\n            const unit = unitObj as any;\r\n            const col = index % formationCols;\r\n            const row = Math.floor(index / formationCols);\r\n            const offsetX = (col - formationCols / 2) * spacing;\r\n            const offsetY = (row - Math.ceil(units.length / formationCols) / 2) * spacing;\r\n            const unitTarget = new Phaser.Math.Vector2(target.x + offsetX, target.y + offsetY);\r\n\r\n            const path = this.scene.pathfinder.findPath(new Phaser.Math.Vector2(unit.x, unit.y), unitTarget);\r\n            if (path) {\r\n                unit.path = path;\r\n                unit.pathStep = 0;\r\n                unit.pathCreatedAt = this.scene.gameTime;\r\n                unit.state = UnitState.IDLE;\r\n                unit.target = null; // Clear combat target\r\n                unit.body.reset(unit.x, unit.y);\r\n            }\r\n        });\r\n\r\n        // Visual feedback\r\n        const iso = toIso(target.x, target.y);\r\n        const circle = this.scene.add.circle(iso.x, iso.y, 5, 0xffffff);\r\n        circle.setScale(1, 0.5);\r\n        circle.setDepth(iso.y);\r\n        this.scene.tweens.add({\r\n            targets: circle,\r\n            scaleX: 0,\r\n            scaleY: 0,\r\n            alpha: 0,\r\n            duration: 500,\r\n            onComplete: () => circle.destroy()\r\n        });\r\n    }\r\n\r\n    public commandAttack(units: Phaser.GameObjects.GameObject[], target: Phaser.GameObjects.GameObject) {\r\n        units.forEach((unitObj) => {\r\n            const unit = unitObj as any;\r\n\r\n            // --- SECURITY BLOCK ---\r\n            // If peaceful mode is active and this is an ENEMY unit, reject the attack command entirely.\r\n            if (this.scene.peacefulMode && unit.getData('owner') !== 0) {\r\n                // Flash a debug indicator if in debug mode\r\n                if (this.scene.debugMode) {\r\n                    const iso = toIso(unit.x, unit.y);\r\n                    const x = this.scene.add.text(iso.x, iso.y, \"X\", { color: '#ff0000', fontSize: '20px' });\r\n                    x.setOrigin(0.5);\r\n                    this.scene.tweens.add({ targets: x, y: iso.y - 20, alpha: 0, duration: 500, onComplete: () => x.destroy() });\r\n                }\r\n                return;\r\n            }\r\n            // ----------------------\r\n\r\n            // Only combat units attack\r\n            if ([UnitType.SOLDIER, UnitType.CAVALRY, UnitType.LEGION, UnitType.ARCHER].includes(unit.unitType)) {\r\n                console.log(`Unit ${unit.unitType} engaging target.`);\r\n                unit.target = target;\r\n                unit.state = UnitState.CHASING;\r\n                unit.path = null; // Clear old move path\r\n                unit.body.reset(unit.x, unit.y);\r\n            } else {\r\n                console.log(`Unit ${unit.unitType} CANNOT attack.`);\r\n            }\r\n        });\r\n\r\n        // Visual Feedback (Red Flash on target)\r\n        if ((target as any).visual) {\r\n            console.log(\"Flashing Target visual\");\r\n            this.scene.tweens.add({\r\n                targets: (target as any).visual,\r\n                alpha: 0.5,\r\n                yoyo: true,\r\n                duration: 100,\r\n                repeat: 2\r\n            });\r\n        } else {\r\n            console.log(\"Target has no visual to flash\");\r\n        }\r\n    }\r\n\r\n    private updateUnitLogic(time: number, delta: number) {\r\n        this.scene.units.getChildren().forEach((item: Phaser.GameObjects.GameObject) => {\r\n            const unit = item as any;\r\n            const body = unit.body as Phaser.Physics.Arcade.Body;\r\n\r\n            if (!body) return;\r\n\r\n            // Failsafe: If peaceful mode is on, force enemy combat units to stop attacking\r\n            if (this.scene.peacefulMode === true && unit.getData('owner') !== 0) {\r\n                if (unit.state === UnitState.CHASING || unit.state === UnitState.ATTACKING) {\r\n                    unit.state = UnitState.IDLE;\r\n                    unit.target = null;\r\n                    body.setVelocity(0, 0);\r\n                }\r\n            }\r\n\r\n            // Combat State Logic\r\n            if (unit.state === UnitState.CHASING || unit.state === UnitState.ATTACKING) {\r\n                this.handleCombatState(unit, time);\r\n            }\r\n            // --- ANIMAL WANDERING AI ---\r\n            else if (unit.unitType === UnitType.ANIMAL) {\r\n                if (body.velocity.length() > 0) {\r\n                    const dest = unit.getData('wanderDest') as Phaser.Math.Vector2;\r\n                    if (dest && Phaser.Math.Distance.Between(unit.x, unit.y, dest.x, dest.y) < 5) {\r\n                        body.setVelocity(0, 0);\r\n                        unit.state = UnitState.IDLE;\r\n                    }\r\n                } else if (Math.random() < 0.005) {\r\n                    const wanderRadius = 100;\r\n                    const angle = Math.random() * Math.PI * 2;\r\n                    const dist = Math.random() * wanderRadius;\r\n                    const tx = Phaser.Math.Clamp(unit.x + Math.cos(angle) * dist, 50, MAP_WIDTH - 50);\r\n                    const ty = Phaser.Math.Clamp(unit.y + Math.sin(angle) * dist, 50, MAP_HEIGHT - 50);\r\n\r\n                    unit.setData('wanderDest', new Phaser.Math.Vector2(tx, ty));\r\n                    this.scene.physics.moveTo(unit, tx, ty, 20);\r\n                    unit.state = UnitState.WANDERING;\r\n                }\r\n            }\r\n            // --- PATH FOLLOWING ---\r\n            else if (unit.path && unit.path.length > 0) {\r\n                if (unit.pathStep >= unit.path.length) {\r\n                    body.setVelocity(0, 0);\r\n                    unit.path = null;\r\n                    if (unit.unitType === UnitType.VILLAGER) {\r\n                        if (unit.state === UnitState.MOVING_TO_WORK) unit.state = UnitState.WORKING;\r\n                        else if (unit.state === UnitState.MOVING_TO_RALLY) unit.state = UnitState.IDLE;\r\n                    }\r\n                    return;\r\n                }\r\n                const nextPoint = unit.path[unit.pathStep];\r\n                const dist = Phaser.Math.Distance.Between(unit.x, unit.y, nextPoint.x, nextPoint.y);\r\n                const speed = UNIT_SPEED[unit.unitType as UnitType] || 100;\r\n\r\n                if (dist < 4) {\r\n                    unit.pathStep++;\r\n                } else {\r\n                    this.scene.physics.moveTo(unit, nextPoint.x, nextPoint.y, speed);\r\n                }\r\n            } else {\r\n                if (body.velocity.length() > 0) body.setVelocity(0, 0);\r\n            }\r\n        });\r\n\r\n        // Separation\r\n        this.scene.physics.overlap(this.scene.units, this.scene.units, (obj1, obj2) => {\r\n            const u1 = obj1 as any;\r\n            const u2 = obj2 as any;\r\n            if (u1 === u2) return;\r\n            const dist = Phaser.Math.Distance.Between(u1.x, u1.y, u2.x, u2.y);\r\n            if (dist < 18) {\r\n                const angle = Phaser.Math.Angle.Between(u2.x, u2.y, u1.x, u1.y);\r\n                const force = (18 - dist) * 1.5;\r\n                u1.body.velocity.x += Math.cos(angle) * force;\r\n                u1.body.velocity.y += Math.sin(angle) * force;\r\n                u2.body.velocity.x -= Math.cos(angle) * force;\r\n                u2.body.velocity.y -= Math.sin(angle) * force;\r\n            }\r\n        });\r\n    }\r\n\r\n    private handleCombatState(unit: any, time: number) {\r\n        const target = unit.target;\r\n\r\n        // Target dead or destroyed\r\n        if (!target || !target.scene) {\r\n            unit.state = UnitState.IDLE;\r\n            unit.target = null;\r\n            unit.body.setVelocity(0, 0);\r\n            return;\r\n        }\r\n\r\n        const dist = Phaser.Math.Distance.Between(unit.x, unit.y, target.x, target.y);\r\n        const range = unit.getData('range') || 40;\r\n        const attackSpeed = unit.getData('attackSpeed') || 1000;\r\n\r\n        // Attack Logic\r\n        if (dist <= range) {\r\n            unit.body.setVelocity(0, 0);\r\n            unit.state = UnitState.ATTACKING;\r\n\r\n            const now = time;\r\n            const last = unit.lastAttackTime || 0;\r\n            const cooldown = attackSpeed;\r\n\r\n            if (now - last > cooldown) {\r\n                console.log(`Attack Ready! Time: ${now}, Last: ${last}, CD: ${cooldown}`);\r\n                unit.lastAttackTime = now;\r\n                this.performAttack(unit, target);\r\n            }\r\n        } else {\r\n            // Chase Logic\r\n            unit.state = UnitState.CHASING;\r\n            const speed = UNIT_SPEED[unit.unitType as UnitType] || 100;\r\n            this.scene.physics.moveTo(unit, target.x, target.y, speed);\r\n        }\r\n    }\r\n\r\n    private performAttack(unit: any, target: any) {\r\n        const dmg = unit.getData('attack') || 10;\r\n        console.log(`PerformAttack: ${unit.unitType} -> Target (HP: ${target.getData('hp')})`);\r\n\r\n        if (unit.unitType === UnitType.ARCHER) {\r\n            // VOLLEY LOGIC\r\n            // Calculate active soldiers based on HP ratio\r\n            const maxHp = unit.getData('maxHp');\r\n            const currentHp = unit.getData('hp');\r\n            const squadSize = UNIT_STATS[UnitType.ARCHER].squadSize;\r\n\r\n            // At least 1 arrow, up to squadSize\r\n            const arrowCount = Math.max(1, Math.ceil((currentHp / maxHp) * squadSize));\r\n            const damagePerArrow = dmg / arrowCount;\r\n\r\n            for (let i = 0; i < arrowCount; i++) {\r\n                // Randomize delay for loose volley feel (0-300ms)\r\n                const delay = Phaser.Math.Between(0, 300);\r\n\r\n                // Add minor random offset to target position for visual variety\r\n                const spread = 15;\r\n                const targetVaried = {\r\n                    x: target.x + Phaser.Math.Between(-spread, spread),\r\n                    y: target.y + Phaser.Math.Between(-spread, spread),\r\n                    scene: target.scene, // Duck-type validity check\r\n                    takeDamage: (amt: number) => { if (target && target.takeDamage) target.takeDamage(amt); }\r\n                };\r\n\r\n                this.scene.time.delayedCall(delay, () => {\r\n                    if (unit.scene && target.scene) { // Validity check\r\n                        this.fireProjectile(unit, targetVaried, damagePerArrow);\r\n                    }\r\n                });\r\n            }\r\n\r\n        } else {\r\n            // Melee Lunge visual\r\n            const visual = unit.visual;\r\n            if (visual) {\r\n                const angle = Phaser.Math.Angle.Between(unit.x, unit.y, target.x, target.y);\r\n                const ox = visual.x;\r\n                const oy = visual.y;\r\n                const lungeX = ox + Math.cos(angle) * 10;\r\n                const lungeY = oy + Math.sin(angle) * 5; // Iso squash\r\n\r\n                this.scene.tweens.add({\r\n                    targets: visual,\r\n                    x: lungeX,\r\n                    y: lungeY,\r\n                    duration: 100,\r\n                    yoyo: true,\r\n                    onComplete: () => {\r\n                        // Reset position exactly to avoid drift\r\n                        const iso = toIso(unit.x, unit.y);\r\n                        visual.setPosition(iso.x, iso.y);\r\n                    }\r\n                });\r\n            }\r\n\r\n            // Apply Damage Immediately (Melee)\r\n            if (target.takeDamage) {\r\n                target.takeDamage(dmg);\r\n            }\r\n        }\r\n    }\r\n\r\n    private fireProjectile(unit: any, target: any, dmg: number) {\r\n        const startIso = toIso(unit.x, unit.y);\r\n        const endIso = toIso(target.x, target.y);\r\n\r\n        // Visual: Arrow (WHITE)\r\n        const arrow = this.scene.add.rectangle(startIso.x, startIso.y - 20, 10, 1, 0xffffff);\r\n        arrow.setDepth(startIso.y + 100);\r\n\r\n        // Visual: Trail Effect (WHITE, LONGER)\r\n        const emitter = this.scene.add.particles(0, 0, 'white_flare', {\r\n            speed: 0,\r\n            scale: { start: 0.2, end: 0 },\r\n            alpha: { start: 0.8, end: 0 },\r\n            lifespan: 500, // Longer trail\r\n            tint: 0xffffff, // White trail\r\n            blendMode: 'ADD',\r\n            frequency: 10,\r\n            follow: arrow\r\n        });\r\n        emitter.setDepth(Number.MAX_VALUE - 100);\r\n\r\n        // Parabolic arc simulation\r\n        // We tween X and Y linearly for ground movement\r\n        // We use a custom update or a separate tween for 'height' to simulate arc\r\n\r\n        // Simple linear movement for now, with a \"height\" offset curve?\r\n        // Actually, just standard Phaser tween with a custom onUpdate is easy.\r\n\r\n        const midX = (startIso.x + endIso.x) / 2;\r\n        const midY = (startIso.y + endIso.y) / 2 - 50; // Arc peak control point\r\n\r\n        // Or we can use a Quadratic Bezier curve\r\n        const curve = new Phaser.Curves.QuadraticBezier(\r\n            new Phaser.Math.Vector2(startIso.x, startIso.y - 15),\r\n            new Phaser.Math.Vector2(midX, midY - 50), // Peak\r\n            new Phaser.Math.Vector2(endIso.x, endIso.y - 10)\r\n        );\r\n\r\n        const projectileObj = { t: 0, vec: new Phaser.Math.Vector2() };\r\n\r\n        this.scene.tweens.add({\r\n            targets: projectileObj,\r\n            t: 1,\r\n            duration: 800, // Slower flight (was 400)\r\n            onUpdate: () => {\r\n                curve.getPoint(projectileObj.t, projectileObj.vec);\r\n                arrow.setPosition(projectileObj.vec.x, projectileObj.vec.y);\r\n\r\n                // Orient arrow along tangent\r\n                const tangent = curve.getTangent(projectileObj.t);\r\n                arrow.setRotation(tangent.angle());\r\n            },\r\n            onComplete: () => {\r\n                arrow.destroy();\r\n                emitter.destroy();\r\n                // Check if target is still valid before damaging\r\n                if (target.takeDamage) {\r\n                    target.takeDamage(dmg);\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    private drawDebugLines() {\r\n        this.debugGraphics.clear();\r\n        this.scene.units.getChildren().forEach((u: any) => {\r\n            const startIso = toIso(u.x, u.y);\r\n\r\n            // Draw Target Lines (Combat)\r\n            if (u.target && u.target.scene) {\r\n                const endIso = toIso(u.target.x, u.target.y);\r\n                this.debugGraphics.lineStyle(2, 0xff0000, 0.7);\r\n                this.debugGraphics.beginPath();\r\n                this.debugGraphics.moveTo(startIso.x, startIso.y);\r\n                this.debugGraphics.lineTo(endIso.x, endIso.y);\r\n                this.debugGraphics.strokePath();\r\n            }\r\n\r\n            // Draw Path Lines (Movement)\r\n            if (u.path && u.path.length > 0) {\r\n                const dest = u.path[u.path.length - 1];\r\n                const endIso = toIso(dest.x, dest.y);\r\n                this.debugGraphics.lineStyle(1, 0xffffff, 0.5);\r\n                this.debugGraphics.beginPath();\r\n                this.debugGraphics.moveTo(startIso.x, startIso.y);\r\n                this.debugGraphics.lineTo(endIso.x, endIso.y);\r\n                this.debugGraphics.strokePath();\r\n            }\r\n        });\r\n    }\r\n\r\n    private drawUnitPaths(time: number) {\r\n        this.pathGraphics.clear();\r\n        this.scene.units.getChildren().forEach((uObj: Phaser.GameObjects.GameObject) => {\r\n            const u = uObj as any;\r\n            const isSelectable = [UnitType.SOLDIER, UnitType.CAVALRY, UnitType.LEGION, UnitType.ARCHER].includes(u.unitType);\r\n\r\n            if (isSelectable && u.path && u.pathCreatedAt) {\r\n                const age = time - u.pathCreatedAt;\r\n                const fadeDuration = 1500;\r\n                if (age < fadeDuration) {\r\n                    const alpha = Phaser.Math.Clamp(1 - (age / fadeDuration), 0, 1);\r\n                    if (u.path.length > u.pathStep) {\r\n                        this.pathGraphics.beginPath();\r\n                        const startIso = toIso(u.x, u.y);\r\n                        this.pathGraphics.moveTo(startIso.x, startIso.y);\r\n                        for (let i = u.pathStep; i < u.path.length; i++) {\r\n                            const pt = u.path[i];\r\n                            const iso = toIso(pt.x, pt.y);\r\n                            this.pathGraphics.lineTo(iso.x, iso.y);\r\n                        }\r\n                        this.pathGraphics.lineStyle(2, 0xffffff, alpha);\r\n                        this.pathGraphics.strokePath();\r\n                        this.pathGraphics.lineStyle(6, 0xffffff, alpha * 0.3);\r\n                        this.pathGraphics.strokePath();\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\LGSM228\\CivStrategy\\game\\utils\\SpatialHash.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Phaser' is defined but never used. Allowed unused vars must match /^_/u.","line":2,"column":8,"nodeType":null,"messageId":"unusedVar","endLine":2,"endColumn":14},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":6,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":6,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[130,133],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[130,133],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":19,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":19,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[476,479],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[476,479],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":28,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":28,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[759,762],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[759,762],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":38,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":38,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1073,1076],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1073,1076],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":48,"column":57,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":48,"endColumn":60,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1372,1375],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1372,1375],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":49,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":49,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1404,1407],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1404,1407],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":7,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\r\nimport Phaser from 'phaser';\r\n\r\nexport class SpatialHash {\r\n    private cellSize: number;\r\n    private buckets: Map<string, Set<any>>;\r\n\r\n    constructor(cellSize: number) {\r\n        this.cellSize = cellSize;\r\n        this.buckets = new Map();\r\n    }\r\n\r\n    private getKey(x: number, y: number): string {\r\n        const cx = Math.floor(x / this.cellSize);\r\n        const cy = Math.floor(y / this.cellSize);\r\n        return `${cx},${cy}`;\r\n    }\r\n\r\n    public insert(entity: any) {\r\n        const key = this.getKey(entity.x, entity.y);\r\n        if (!this.buckets.has(key)) {\r\n            this.buckets.set(key, new Set());\r\n        }\r\n        this.buckets.get(key)!.add(entity);\r\n        entity.setData('spatialKey', key);\r\n    }\r\n\r\n    public remove(entity: any) {\r\n        const key = entity.getData('spatialKey');\r\n        if (key && this.buckets.has(key)) {\r\n            this.buckets.get(key)!.delete(entity);\r\n            if (this.buckets.get(key)!.size === 0) {\r\n                this.buckets.delete(key);\r\n            }\r\n        }\r\n    }\r\n\r\n    public update(entity: any) {\r\n        const oldKey = entity.getData('spatialKey');\r\n        const newKey = this.getKey(entity.x, entity.y);\r\n\r\n        if (oldKey !== newKey) {\r\n            this.remove(entity);\r\n            this.insert(entity);\r\n        }\r\n    }\r\n\r\n    public query(x: number, y: number, radius: number): any[] {\r\n        const results: any[] = [];\r\n        const checkedKeys = new Set<string>();\r\n\r\n        // Calculate range of cells to check\r\n        const startX = Math.floor((x - radius) / this.cellSize);\r\n        const endX = Math.floor((x + radius) / this.cellSize);\r\n        const startY = Math.floor((y - radius) / this.cellSize);\r\n        const endY = Math.floor((y + radius) / this.cellSize);\r\n\r\n        for (let cx = startX; cx <= endX; cx++) {\r\n            for (let cy = startY; cy <= endY; cy++) {\r\n                const key = `${cx},${cy}`;\r\n                if (checkedKeys.has(key)) continue;\r\n                checkedKeys.add(key);\r\n\r\n                const bucket = this.buckets.get(key);\r\n                if (bucket) {\r\n                    bucket.forEach(entity => {\r\n                        // Rough check first? No, just return candidates\r\n                        results.push(entity);\r\n                    });\r\n                }\r\n            }\r\n        }\r\n\r\n        return results;\r\n    }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\LGSM228\\CivStrategy\\game\\utils\\iso.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\LGSM228\\CivStrategy\\index.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\LGSM228\\CivStrategy\\types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\LGSM228\\CivStrategy\\vite.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]}]